!
! auto-generated by op2.py on 2013-02-13 12:12
!

MODULE ADT_CALC_MODULE
USE OP2_FORTRAN_DECLARATIONS
USE OP2_FORTRAN_RT_SUPPORT
USE ISO_C_BINDING
USE OP2_CONSTANTS

#ifdef _OPENMP
  USE OMP_LIB
#endif

! variable declarations
REAL(kind=4) :: loopTimeHostadt_calc
REAL(kind=4) :: loopTimeKerneladt_calc
INTEGER(kind=4) :: numberCalledadt_calc

LOGICAL :: firstTime_adt_calc = .TRUE.
type ( c_ptr )  :: planRet_adt_calc
type ( op_plan ) , POINTER :: actualPlan_adt_calc
type ( c_ptr ) , POINTER, DIMENSION(:) :: ind_maps_adt_calc
type ( c_ptr ) , POINTER, DIMENSION(:) :: mappingArray_adt_calc

INTEGER(kind=4), POINTER, DIMENSION(:) :: ind_maps1_adt_calc

INTEGER(kind=2), POINTER, DIMENSION(:) :: mappingArray1_adt_calc
INTEGER(kind=2), POINTER, DIMENSION(:) :: mappingArray2_adt_calc
INTEGER(kind=2), POINTER, DIMENSION(:) :: mappingArray3_adt_calc
INTEGER(kind=2), POINTER, DIMENSION(:) :: mappingArray4_adt_calc

INTEGER(kind=4) :: mappingArray1Size_adt_calc
INTEGER(kind=4) :: mappingArray2Size_adt_calc
INTEGER(kind=4) :: mappingArray3Size_adt_calc
INTEGER(kind=4) :: mappingArray4Size_adt_calc

INTEGER(kind=4), POINTER, DIMENSION(:) :: blkmap_adt_calc
INTEGER(kind=4) :: blkmapSize_adt_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: ind_offs_adt_calc
INTEGER(kind=4) :: ind_offsSize_adt_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: ind_sizes_adt_calc
INTEGER(kind=4) :: ind_sizesSize_adt_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: nelems_adt_calc
INTEGER(kind=4) :: nelemsSize_adt_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: nthrcol_adt_calc
INTEGER(kind=4) :: nthrcolSize_adt_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: offset_adt_calc
INTEGER(kind=4) :: offsetSize_adt_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: thrcol_adt_calc
INTEGER(kind=4) :: thrcolSize_adt_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: ncolblk_adt_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: pnindirect_adt_calc

CONTAINS

! user function
include "adt_calc.inc"


! x86 kernel function
SUBROUTINE op_x86_adt_calc( &
  &  opDat1,   &
  &  opDat5,   &
  &  opDat6,   &
  &  ind_maps1, &
  &  mappingArray1, &
  &  mappingArray2, &
  &  mappingArray3, &
  &  mappingArray4, &
  &  ind_sizes, &
  &  ind_offs,  &
  &  blkmap,        &
  &  offset,        &
  &  nelems,        &
  &  nthrcol,       &
  &  thrcol,        &
  &  blockOffset,   &
  &  blockID )

  IMPLICIT NONE

! local variables
  real(8), DIMENSION(0:*) :: opDat1
  real(8), DIMENSION(0:*) :: opDat5
  real(8), DIMENSION(0:*) :: opDat6

  INTEGER(kind=4), DIMENSION(0:), target :: ind_maps1

  INTEGER(kind=2), DIMENSION(0:*) :: mappingArray1
  INTEGER(kind=2), DIMENSION(0:*) :: mappingArray2
  INTEGER(kind=2), DIMENSION(0:*) :: mappingArray3
  INTEGER(kind=2), DIMENSION(0:*) :: mappingArray4

  INTEGER(kind=4), DIMENSION(0:*) :: ind_sizes
  INTEGER(kind=4), DIMENSION(0:*) :: ind_offs
  INTEGER(kind=4), DIMENSION(0:*) :: blkmap
  INTEGER(kind=4), DIMENSION(0:*) :: offset
  INTEGER(kind=4), DIMENSION(0:*) :: nelems
  INTEGER(kind=4), DIMENSION(0:*) :: nthrcol
  INTEGER(kind=4), DIMENSION(0:*) :: thrcol
  INTEGER(kind=4) :: blockOffset
  INTEGER(kind=4) :: blockID
  INTEGER(kind=4) :: threadBlockOffset
  INTEGER(kind=4) :: threadBlockID
  INTEGER(kind=4) :: numberOfActiveThreads
  INTEGER(kind=4) :: i1
  INTEGER(kind=4) :: i2
  REAL(kind=8), DIMENSION(0:128000 - 1), target :: sharedFloat8

  INTEGER(kind=4), POINTER, DIMENSION(:) :: opDat1IndirectionMap
  real(8), POINTER, DIMENSION(:) :: opDat1SharedIndirection
  INTEGER(kind=4) :: opDat1nBytes
  INTEGER(kind=4) :: opDat1RoundUp
  INTEGER(kind=4) :: opDat1SharedIndirectionSize
  INTEGER(kind=4) :: numOfColours
  INTEGER(kind=4) :: numberOfActiveThreadsCeiling
  INTEGER(kind=4) :: colour1
  INTEGER(kind=4) :: colour2

  threadBlockID = blkmap(blockID + blockOffset)
  numberOfActiveThreads = nelems(threadBlockID)
  threadBlockOffset = offset(threadBlockID)
  numberOfActiveThreadsCeiling = numberOfActiveThreads
  numOfColours = nthrcol(threadBlockID)

  opDat1SharedIndirectionSize = ind_sizes(0 + threadBlockID * 1)
  opDat1IndirectionMap => ind_maps1(ind_offs(0 + threadBlockID * 1):)
  opDat1nBytes = 0
  opDat1SharedIndirection => sharedFloat8(opDat1nBytes:)

  DO i1 = 0, opDat1SharedIndirectionSize-1, 1
    DO i2 = 0, 2-1, 1
      opDat1SharedIndirection(i2 + i1 * 2 + 1) = opDat1(i2 + opDat1IndirectionMap(i1 + 1) * 2)
    END DO
  END DO

  DO i1 = 0, numberOfActiveThreadsCeiling-1, 1
      colour2 = -1
    IF (i1 < numberOfActiveThreads) THEN

! kernel call
    CALL adt_calc( &
      & opDat1SharedIndirection(1 + mappingArray1(i1 + threadBlockOffset) * 2:1 + mappingArray1(i1 + threadBlockOffset) * 2 + 2 - 1), &
      & opDat1SharedIndirection(1 + mappingArray2(i1 + threadBlockOffset) * 2:1 + mappingArray2(i1 + threadBlockOffset) * 2 + 2 - 1), &
      & opDat1SharedIndirection(1 + mappingArray3(i1 + threadBlockOffset) * 2:1 + mappingArray3(i1 + threadBlockOffset) * 2 + 2 - 1), &
      & opDat1SharedIndirection(1 + mappingArray4(i1 + threadBlockOffset) * 2:1 + mappingArray4(i1 + threadBlockOffset) * 2 + 2 - 1), &
      & opDat5((i1 + threadBlockOffset) * 4:(i1 + threadBlockOffset) * 4 + 4 - 1), &
      & opDat6((i1 + threadBlockOffset) * 1) &
      & )
      colour2 = thrcol(i1 + threadBlockOffset)
    END IF


    DO colour1 = 0, numOfColours-1, 1
      IF (colour2 .EQ. colour1) THEN
      END IF
    END DO
  END DO

END SUBROUTINE

SUBROUTINE adt_calc_host( userSubroutine, set, &
  & opArg1, &
  & opArg2, &
  & opArg3, &
  & opArg4, &
  & opArg5, &
  & opArg6 )

  IMPLICIT NONE
  character(len=8), INTENT(IN) :: userSubroutine
  type ( op_set ) , INTENT(IN) :: set

  type ( op_arg ) , INTENT(IN) :: opArg1
  type ( op_arg ) , INTENT(IN) :: opArg2
  type ( op_arg ) , INTENT(IN) :: opArg3
  type ( op_arg ) , INTENT(IN) :: opArg4
  type ( op_arg ) , INTENT(IN) :: opArg5
  type ( op_arg ) , INTENT(IN) :: opArg6

  type ( op_arg ) , DIMENSION(6) :: opArgArray
  INTEGER(kind=4) :: numberOfOpDats
  INTEGER(kind=4) :: returnMPIHaloExchange
  INTEGER(kind=4) :: returnSetKernelTiming
  type ( op_set_core ) , POINTER :: opSetCore

  type ( op_set_core ) , POINTER :: opSet1Core
  real(8), POINTER, DIMENSION(:) :: opDat1Local
  INTEGER(kind=4) :: opDat1Cardinality

  type ( op_set_core ) , POINTER :: opSet5Core
  real(8), POINTER, DIMENSION(:) :: opDat5Local
  INTEGER(kind=4) :: opDat5Cardinality

  type ( op_set_core ) , POINTER :: opSet6Core
  real(8), POINTER, DIMENSION(:) :: opDat6Local
  INTEGER(kind=4) :: opDat6Cardinality


  type ( op_dat_core ) , POINTER :: opDat1Core
  type ( op_dat_core ) , POINTER :: opDat2Core
  type ( op_dat_core ) , POINTER :: opDat3Core
  type ( op_dat_core ) , POINTER :: opDat4Core
  type ( op_dat_core ) , POINTER :: opDat5Core
  type ( op_dat_core ) , POINTER :: opDat6Core

  type ( op_map_core ) , POINTER :: opMap1Core
  type ( op_map_core ) , POINTER :: opMap2Core
  type ( op_map_core ) , POINTER :: opMap3Core
  type ( op_map_core ) , POINTER :: opMap4Core
  type ( op_map_core ) , POINTER :: opMap5Core
  type ( op_map_core ) , POINTER :: opMap6Core

  INTEGER(kind=4) :: threadID
  INTEGER(kind=4) :: numberOfThreads
  INTEGER(kind=4) :: partitionSize
  INTEGER(kind=4), DIMENSION(1:6) :: opDatArray
  INTEGER(kind=4), DIMENSION(1:6) :: mappingIndicesArray
  INTEGER(kind=4), DIMENSION(1:6) :: mappingArray
  INTEGER(kind=4), DIMENSION(1:6) :: accessDescriptorArray
  INTEGER(kind=4), DIMENSION(1:6) :: indirectionDescriptorArray
  INTEGER(kind=4), DIMENSION(1:6) :: opDatTypesArray
  INTEGER(kind=4), DIMENSION(1:8) :: timeArrayStart
  INTEGER(kind=4), DIMENSION(1:8) :: timeArrayEnd
  INTEGER(kind=4) :: numberOfIndirectOpDats
  INTEGER(kind=4) :: blockOffset
  INTEGER(kind=4) :: nblocks
  REAL(kind=8) :: startTimeHost
  REAL(kind=8) :: endTimeHost
  REAL(kind=8) :: startTimeKernel
  REAL(kind=8) :: endTimeKernel
  REAL(kind=8) :: accumulatorHostTime
  REAL(kind=8) :: accumulatorKernelTime
  INTEGER(kind=4) :: i1
  INTEGER(kind=4) :: i2



  numberOfOpDats = 6

  opArgArray(1) = opArg1
  opArgArray(2) = opArg2
  opArgArray(3) = opArg3
  opArgArray(4) = opArg4
  opArgArray(5) = opArg5
  opArgArray(6) = opArg6

  returnMPIHaloExchange = op_mpi_halo_exchanges(set%setCPtr,numberOfOpDats,opArgArray)
  IF (returnMPIHaloExchange .EQ. 0) THEN
    CALL op_mpi_wait_all(numberOfOpDats,opArgArray)
    CALL op_mpi_set_dirtybit(numberOfOpDats,opArgArray)
    RETURN
  END IF



#ifdef OP_PART_SIZE_1
  partitionSize = OP_PART_SIZE_1
#else
  partitionSize = 0
#endif

#ifdef _OPENMP
  numberOfThreads = omp_get_max_threads()
#else
  numberOfThreads = 1
#endif
  indirectionDescriptorArray(1) = 0
  indirectionDescriptorArray(2) = 0
  indirectionDescriptorArray(3) = 0
  indirectionDescriptorArray(4) = 0
  indirectionDescriptorArray(5) = -1
  indirectionDescriptorArray(6) = -1

  numberOfIndirectOpDats = 1

  planRet_adt_calc = FortranPlanCaller( &
  & userSubroutine, &
  & set%setCPtr, &
  & partitionSize, &
  & numberOfOpDats, &
  & opArgArray, &
  & numberOfIndirectOpDats, &
  & indirectionDescriptorArray)

  CALL c_f_pointer(planRet_adt_calc,actualPlan_adt_calc)
  CALL c_f_pointer(actualPlan_adt_calc%nindirect,pnindirect_adt_calc,(/numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_adt_calc%ind_maps,ind_maps_adt_calc,(/numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_adt_calc%maps,mappingArray_adt_calc,(/numberOfOpDats/))
  CALL c_f_pointer(actualPlan_adt_calc%ncolblk,ncolblk_adt_calc,(/set%setPtr%size/))
  CALL c_f_pointer(actualPlan_adt_calc%ind_sizes,ind_sizes_adt_calc,(/actualPlan_adt_calc%nblocks * numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_adt_calc%ind_offs,ind_offs_adt_calc,(/actualPlan_adt_calc%nblocks * numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_adt_calc%blkmap,blkmap_adt_calc,(/actualPlan_adt_calc%nblocks/))
  CALL c_f_pointer(actualPlan_adt_calc%offset,offset_adt_calc,(/actualPlan_adt_calc%nblocks/))
  CALL c_f_pointer(actualPlan_adt_calc%nelems,nelems_adt_calc,(/actualPlan_adt_calc%nblocks/))
  CALL c_f_pointer(actualPlan_adt_calc%nthrcol,nthrcol_adt_calc,(/actualPlan_adt_calc%nblocks/))
  CALL c_f_pointer(actualPlan_adt_calc%thrcol,thrcol_adt_calc,(/set%setPtr%size/))

  CALL c_f_pointer(ind_maps_adt_calc(1),ind_maps1_adt_calc,(/pnindirect_adt_calc(1)/))

  IF (indirectionDescriptorArray(1) >= 0) THEN
    CALL c_f_pointer(mappingArray_adt_calc(1),mappingArray1_adt_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(2) >= 0) THEN
    CALL c_f_pointer(mappingArray_adt_calc(2),mappingArray2_adt_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(3) >= 0) THEN
    CALL c_f_pointer(mappingArray_adt_calc(3),mappingArray3_adt_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(4) >= 0) THEN
    CALL c_f_pointer(mappingArray_adt_calc(4),mappingArray4_adt_calc,(/set%setPtr%size/))
  END IF


  opSetCore => set%setPtr

  opDat1Cardinality = opArg1%dim * getSetSizeFromOpArg(opArg1)
  opDat5Cardinality = opArg5%dim * getSetSizeFromOpArg(opArg5)
  opDat6Cardinality = opArg6%dim * getSetSizeFromOpArg(opArg6)

  CALL c_f_pointer(opArg1%data,opDat1Local,(/opDat1Cardinality/))
  CALL c_f_pointer(opArg5%data,opDat5Local,(/opDat5Cardinality/))
  CALL c_f_pointer(opArg6%data,opDat6Local,(/opDat6Cardinality/))


  blockOffset = 0

  DO i1 = 0, actualPlan_adt_calc%ncolors-1, 1
    IF (i1 .EQ. actualPlan_adt_calc%ncolors_core) THEN
      CALL op_mpi_wait_all(numberOfOpDats,opArgArray)
    END IF

    nblocks = ncolblk_adt_calc(i1 + 1)
    !$OMP PARALLEL DO private (threadID)
    DO i2 = 0, nblocks-1, 1
      threadID = omp_get_thread_num()
      CALL op_x86_adt_calc( &
      & opDat1Local, &
      & opDat5Local, &
      & opDat6Local, &
      & ind_maps1_adt_calc, &
      & mappingArray1_adt_calc, &
      & mappingArray2_adt_calc, &
      & mappingArray3_adt_calc, &
      & mappingArray4_adt_calc, &
      & ind_sizes_adt_calc, &
      & ind_offs_adt_calc, &
      & blkmap_adt_calc, &
      & offset_adt_calc, &
      & nelems_adt_calc, &
      & nthrcol_adt_calc, &
      & thrcol_adt_calc, &
      & blockOffset,i2)
    END DO
    !$OMP END PARALLEL DO
    blockOffset = blockOffset + nblocks
  END DO



  CALL op_mpi_set_dirtybit(numberOfOpDats,opArgArray)

END SUBROUTINE
END MODULE ADT_CALC_MODULE
