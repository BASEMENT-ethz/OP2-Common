!
! auto-generated by op2.py on 2015-01-26 23:17
!

MODULE GETQ_CHRISTIENSEN_BC_MODULE
USE OP2_FORTRAN_DECLARATIONS
USE OP2_FORTRAN_RT_SUPPORT
USE ISO_C_BINDING
USE kinds_mod,    ONLY: ink,rlk
USE parameters_mod,ONLY: LI

USE OMP_LIB


CONTAINS

!DEC$ ATTRIBUTES FORCEINLINE :: getq_christiensen_bc
SUBROUTINE getq_christiensen_bc(ielel,scratch,indtype1,indtype2, &
&                               indtype3,indtype4,iside)
    USE kinds_mod,ONLY: rlk
    USE parameters_mod,ONLY: N_SHAPE

    implicit none

    REAL(KIND=rlk), DIMENSION(N_SHAPE), INTENT(OUT) :: scratch
    INTEGER(KIND=ink), INTENT(INOUT) :: iside
    INTEGER(KIND=ink), INTENT(IN) :: indtype1, indtype2, &
&                                    indtype3, indtype4
    INTEGER(KIND=ink), DIMENSION(N_SHAPE), INTENT(IN) :: ielel
    INTEGER(KIND=ink) :: in1,in2,ins,ic1,ic2
    INTEGER(kind=ink), DIMENSION(4) :: indtype


    indtype(1) = indtype1
    indtype(2) = indtype2
    indtype(3) = indtype3
    indtype(4) = indtype4

    ins=iside+2_ink
    in1=ielel(iside)
    in2=ielel(ins)
    IF (in1.EQ.0_ink) THEN
      ic1=iside
      ic2=MOD(iside,N_SHAPE)+1_ink
      IF (((indtype(ic1).LT.0_ink).AND.(indtype(ic2).LT.0_ink)).AND.&
&          (in2.NE.0_ink)) THEN
        scratch(1)=1.0_rlk
        scratch(3)=1.0_rlk
      ELSE
        scratch(1)=0.0_rlk
        scratch(3)=0.0_rlk
      ENDIF
    ENDIF
    IF (in2.EQ.0_ink) THEN
      ic1=ins
      ic2=MOD(ins,N_SHAPE)+1_ink
      IF (((indtype(ic1).LT.0_ink).AND.(indtype(ic2).LT.0_ink)).AND.&
&          (in1.NE.0_ink)) THEN
        scratch(2)=1.0_rlk
        scratch(4)=1.0_rlk
      ELSE
        scratch(2)=0.0_rlk
        scratch(4)=0.0_rlk
      ENDIF
    ENDIF

  END SUBROUTINE getq_christiensen_bc


SUBROUTINE op_wrap_getq_christiensen_bc( &
& opDat3Local, &
& opDat1Local, &
& opDat2Local, &
& opDat7Local, &
& opDat3Map, &
& opDat3MapDim, &
& bottom,top)
integer(4) opDat3Local(1,*)
integer(4) opDat1Local(4,*)
real(8) opDat2Local(4,*)
integer(4) opDat7Local(1)
INTEGER(kind=4) opDat3Map(*)
INTEGER(kind=4) opDat3MapDim
INTEGER(kind=4) bottom,top,i1
INTEGER(kind=4) map3idx, map4idx, map5idx, map6idx

DO i1 = bottom, top-1, 1
  map3idx = opDat3Map(1 + i1 * opDat3MapDim + 0)+1
  map4idx = opDat3Map(1 + i1 * opDat3MapDim + 1)+1
  map5idx = opDat3Map(1 + i1 * opDat3MapDim + 2)+1
  map6idx = opDat3Map(1 + i1 * opDat3MapDim + 3)+1
! kernel call
CALL getq_christiensen_bc( &
  & opDat1Local(1,i1+1), &
  & opDat2Local(1,i1+1), &
  & opDat3Local(1,map3idx), &
  & opDat3Local(1,map4idx), &
  & opDat3Local(1,map5idx), &
  & opDat3Local(1,map6idx), &
  & opDat7Local(1) &
  & )
END DO
END SUBROUTINE
SUBROUTINE getq_christiensen_bc_host( userSubroutine, set, &
& opArg1, &
& opArg2, &
& opArg3, &
& opArg4, &
& opArg5, &
& opArg6, &
& opArg7 )

IMPLICIT NONE
character(kind=c_char,len=*), INTENT(IN) :: userSubroutine
type ( op_set ) , INTENT(IN) :: set

type ( op_arg ) , INTENT(IN) :: opArg1
type ( op_arg ) , INTENT(IN) :: opArg2
type ( op_arg ) , INTENT(IN) :: opArg3
type ( op_arg ) , INTENT(IN) :: opArg4
type ( op_arg ) , INTENT(IN) :: opArg5
type ( op_arg ) , INTENT(IN) :: opArg6
type ( op_arg ) , INTENT(IN) :: opArg7

type ( op_arg ) , DIMENSION(7) :: opArgArray
INTEGER(kind=4) :: numberOfOpDats
INTEGER(kind=4) :: n_upper
type ( op_set_core ) , POINTER :: opSetCore

INTEGER(kind=4), POINTER, DIMENSION(:) :: opDat3Map
INTEGER(kind=4) :: opDat3MapDim
integer(4), POINTER, DIMENSION(:) :: opDat3Local
INTEGER(kind=4) :: opDat3Cardinality

integer(4), POINTER, DIMENSION(:) :: opDat1Local
INTEGER(kind=4) :: opDat1Cardinality

real(8), POINTER, DIMENSION(:) :: opDat2Local
INTEGER(kind=4) :: opDat2Cardinality

integer(4), POINTER, DIMENSION(:) :: opDat7Local
INTEGER(kind=4) :: threadID
INTEGER(kind=4) :: numberOfThreads
INTEGER(kind=4), DIMENSION(1:8) :: timeArrayStart
INTEGER(kind=4), DIMENSION(1:8) :: timeArrayEnd
REAL(kind=8) :: startTime
REAL(kind=8) :: endTime
INTEGER(kind=4) :: returnSetKernelTiming
LOGICAL :: firstTime_getq_christiensen_bc = .TRUE.
type ( c_ptr )  :: planRet_getq_christiensen_bc
type ( op_plan ) , POINTER :: actualPlan_getq_christiensen_bc
INTEGER(kind=4), POINTER, DIMENSION(:) :: ncolblk_getq_christiensen_bc
INTEGER(kind=4), POINTER, DIMENSION(:) :: blkmap_getq_christiensen_bc
INTEGER(kind=4), POINTER, DIMENSION(:) :: nelems_getq_christiensen_bc
INTEGER(kind=4), POINTER, DIMENSION(:) :: offset_getq_christiensen_bc
INTEGER(kind=4), DIMENSION(1:7) :: indirectionDescriptorArray
INTEGER(kind=4) :: numberOfIndirectOpDats
INTEGER(kind=4) :: blockOffset
INTEGER(kind=4) :: nblocks
INTEGER(kind=4) :: partitionSize
INTEGER(kind=4) :: blockID
INTEGER(kind=4) :: nelem
INTEGER(kind=4) :: offset_b


INTEGER(kind=4) :: i1,i2,n

numberOfOpDats = 7

opArgArray(1) = opArg1
opArgArray(2) = opArg2
opArgArray(3) = opArg3
opArgArray(4) = opArg4
opArgArray(5) = opArg5
opArgArray(6) = opArg6
opArgArray(7) = opArg7

returnSetKernelTiming = setKernelTime(22 , userSubroutine//C_NULL_CHAR, &
& 0.d0, 0.00000,0.00000, 0)
call op_timers_core(startTime)

n_upper = op_mpi_halo_exchanges(set%setCPtr,numberOfOpDats,opArgArray)

  partitionSize = 0

  numberOfThreads = omp_get_max_threads()
  indirectionDescriptorArray(1) = -1
  indirectionDescriptorArray(2) = -1
  indirectionDescriptorArray(3) = 0
  indirectionDescriptorArray(4) = 0
  indirectionDescriptorArray(5) = 0
  indirectionDescriptorArray(6) = 0
  indirectionDescriptorArray(7) = -1

  numberOfIndirectOpDats = 1

  planRet_getq_christiensen_bc = FortranPlanCaller( &
  & userSubroutine//C_NULL_CHAR, &
  & set%setCPtr, &
  & partitionSize, &
  & numberOfOpDats, &
  & opArgArray, &
  & numberOfIndirectOpDats, &
  & indirectionDescriptorArray,2)

  CALL c_f_pointer(planRet_getq_christiensen_bc,actualPlan_getq_christiensen_bc)
  CALL c_f_pointer(actualPlan_getq_christiensen_bc%ncolblk,ncolblk_getq_christiensen_bc,(/actualPlan_getq_christiensen_bc%ncolors_core/))
  CALL c_f_pointer(actualPlan_getq_christiensen_bc%blkmap,blkmap_getq_christiensen_bc,(/actualPlan_getq_christiensen_bc%nblocks/))
  CALL c_f_pointer(actualPlan_getq_christiensen_bc%offset,offset_getq_christiensen_bc,(/actualPlan_getq_christiensen_bc%nblocks/))
  CALL c_f_pointer(actualPlan_getq_christiensen_bc%nelems,nelems_getq_christiensen_bc,(/actualPlan_getq_christiensen_bc%nblocks/))

  opSetCore => set%setPtr

  opDat3Cardinality = opArg3%dim * getSetSizeFromOpArg(opArg3)
  opDat3MapDim = getMapDimFromOpArg(opArg3)
  opDat1Cardinality = opArg1%dim * getSetSizeFromOpArg(opArg1)
  opDat2Cardinality = opArg2%dim * getSetSizeFromOpArg(opArg2)
  CALL c_f_pointer(opArg3%data,opDat3Local,(/opDat3Cardinality/))
  CALL c_f_pointer(opArg3%map_data,opDat3Map,(/opSetCore%size*opDat3MapDim/))
  CALL c_f_pointer(opArg1%data,opDat1Local,(/opDat1Cardinality/))
  CALL c_f_pointer(opArg2%data,opDat2Local,(/opDat2Cardinality/))
  CALL c_f_pointer(opArg7%data,opDat7Local, (/opArg7%dim/))


  blockOffset = 0

  DO i1 = 0, actualPlan_getq_christiensen_bc%ncolors-1, 1
    IF (i1 .EQ. actualPlan_getq_christiensen_bc%ncolors_core) THEN
      CALL op_mpi_wait_all(numberOfOpDats,opArgArray)
    END IF

    nblocks = ncolblk_getq_christiensen_bc(i1 + 1)
    !$OMP PARALLEL DO private (threadID, blockID, nelem, offset_b)
    DO i2 = 0, nblocks-1, 1
      threadID = omp_get_thread_num()
      blockID = blkmap_getq_christiensen_bc(i2+blockOffset+1)
      nelem = nelems_getq_christiensen_bc(blockID+1)
      offset_b = offset_getq_christiensen_bc(blockID+1)
      CALL op_wrap_getq_christiensen_bc( &
      & opDat3Local, &
      & opDat1Local, &
      & opDat2Local, &
      & opDat7Local, &
      & opDat3Map, &
      & opDat3MapDim, &
      & offset_b, offset_b+nelem)
    END DO
    !$OMP END PARALLEL DO
    blockOffset = blockOffset + nblocks
  END DO
  IF ((n_upper .EQ. 0) .OR. (n_upper .EQ. opSetCore%core_size)) THEN
    CALL op_mpi_wait_all(numberOfOpDats,opArgArray)
  END IF

  CALL op_mpi_set_dirtybit(numberOfOpDats,opArgArray)

  call op_timers_core(endTime)

  returnSetKernelTiming = setKernelTime(22 , userSubroutine//C_NULL_CHAR, &
  & endTime-startTime, actualPlan_getq_christiensen_bc%transfer,actualPlan_getq_christiensen_bc%transfer2, 1)
END SUBROUTINE
END MODULE