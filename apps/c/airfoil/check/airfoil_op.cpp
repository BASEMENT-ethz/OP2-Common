//
// auto-generated by op2.m on 20-Dec-2011 15:33:39
//

/*
Open source copyright declaration based on BSD open source template:
http://www.opensource.org/licenses/bsd-license.php

* Copyright (c) 2009-2011, Mike Giles
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * The name of Mike Giles may not be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//
//     Nonlinear airfoil lift calculation
//
//     Written by Mike Giles, 2010-2011, based on FORTRAN code
//     by Devendra Ghate and Mike Giles, 2005
//

//
// standard headers
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "b64/cencode.h"
#include "b64/cdecode.h"

// global constants

double gam, gm1, cfl, eps, mach, alpha, qinf[4];

//
// OP header file
//

#include "op_lib_cpp.h"
#include "op_seq.h"



//
// op_par_loop declarations
//

void op_par_loop_save_soln(char const *, op_set,
  op_arg,
  op_arg );

void op_par_loop_adt_calc(char const *, op_set,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg );

void op_par_loop_res_calc(char const *, op_set,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg );

void op_par_loop_bres_calc(char const *, op_set,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg );

void op_par_loop_update(char const *, op_set,
  op_arg,
  op_arg,
  op_arg,
  op_arg,
  op_arg );

//
// kernel routines for parallel loops
//

#include "save_soln.h"
#include "adt_calc.h"
#include "res_calc.h"
#include "bres_calc.h"
#include "update.h"

// main program

int main(int argc, char **argv){

  int    *becell, *ecell,  *bound, *bedge, *edge, *cell;
  double  *x, *q, *qold, *adt, *res;

  int    nnode,ncell,nedge,nbedge,niter;
  double  rms;

// read in grid

  printf("reading in grid \n");

  FILE *fp;
  if ( (fp = fopen("./new_grid.dat","r")) == NULL) { ///new_grid.dat
    printf("can't open file new_grid.dat\n"); exit(-1);
  }

  if (fscanf(fp,"%d %d %d %d \n",&nnode, &ncell, &nedge, &nbedge) != 4) {
    printf("error reading from new_grid.dat\n"); exit(-1);
  }

  cell   = (int *) malloc(4*ncell*sizeof(int));
  edge   = (int *) malloc(2*nedge*sizeof(int));
  ecell  = (int *) malloc(2*nedge*sizeof(int));
  bedge  = (int *) malloc(2*nbedge*sizeof(int));
  becell = (int *) malloc(  nbedge*sizeof(int));
  bound  = (int *) malloc(  nbedge*sizeof(int));

  x      = (double *) malloc(2*nnode*sizeof(double));
  q      = (double *) malloc(4*ncell*sizeof(double));
  qold   = (double *) malloc(4*ncell*sizeof(double));
  res    = (double *) malloc(4*ncell*sizeof(double));
  adt    = (double *) malloc(  ncell*sizeof(double));

  for (int n=0; n<nnode; n++) {
    if (fscanf(fp,"%lf %lf \n",&x[2*n], &x[2*n+1]) != 2) {
      printf("error reading from new_grid.dat\n"); exit(-1);
    }
  }

  for (int n=0; n<ncell; n++) {
    if (fscanf(fp,"%d %d %d %d \n",&cell[4*n  ], &cell[4*n+1],
    &cell[4*n+2], &cell[4*n+3]) != 4) {
      printf("error reading from new_grid.dat\n"); exit(-1);
    }
  }

  for (int n=0; n<nedge; n++) {
    if (fscanf(fp,"%d %d %d %d \n",&edge[2*n], &edge[2*n+1],
    &ecell[2*n],&ecell[2*n+1]) != 4) {
      printf("error reading from new_grid.dat\n"); exit(-1);
    }
  }

  for (int n=0; n<nbedge; n++) {
    if (fscanf(fp,"%d %d %d %d \n",&bedge[2*n],&bedge[2*n+1],
    &becell[n], &bound[n]) != 4) {
      printf("error reading from new_grid.dat\n"); exit(-1);
    }
  }

  fclose(fp);

// set constants and initialise flow field and residual

  printf("initialising flow field \n");

  gam = 1.4f;
  gm1 = gam - 1.0f;
  cfl = 0.9f;
  eps = 0.05f;

  double mach  = 0.4f;
  double alpha = 3.0f*atan(1.0f)/45.0f;
  double p     = 1.0f;
  double r     = 1.0f;
  double u     = sqrt(gam*p/r)*mach;
  double e     = p/(r*gm1) + 0.5f*u*u;

  qinf[0] = r;
  qinf[1] = r*u;
  qinf[2] = 0.0f;
  qinf[3] = r*e;

  for (int n=0; n<ncell; n++) {
    for (int m=0; m<4; m++) {
      q[4*n+m] = qinf[m];
      res[4*n+m] = 0.0f;
    }
  }

// OP initialisation

  op_init(argc,argv,2);

// declare sets, pointers, datasets and global constants

  op_set nodes  = op_decl_set(nnode,  "nodes");
  op_set edges  = op_decl_set(nedge,  "edges");
  op_set bedges = op_decl_set(nbedge, "bedges");
  op_set cells  = op_decl_set(ncell,  "cells");

  op_map pedge   = op_decl_map(edges, nodes,2,edge,  "pedge");
  op_map pecell  = op_decl_map(edges, cells,2,ecell, "pecell");
  op_map pbedge  = op_decl_map(bedges,nodes,2,bedge, "pbedge");
  op_map pbecell = op_decl_map(bedges,cells,1,becell,"pbecell");
  op_map pcell   = op_decl_map(cells, nodes,4,cell,  "pcell");

  op_dat p_bound = op_decl_dat(bedges,1,"int"  ,bound,"p_bound");
  op_dat p_x     = op_decl_dat(nodes ,2,"double",x    ,"p_x");
  op_dat p_q     = op_decl_dat(cells ,4,"double",q    ,"p_q");
  op_dat p_qold  = op_decl_dat(cells ,4,"double",qold ,"p_qold");
  op_dat p_adt   = op_decl_dat(cells ,1,"double",adt  ,"p_adt");
  op_dat p_res   = op_decl_dat(cells ,4,"double",res  ,"p_res");

  op_decl_const2("gam",1,"double",&gam  );
  op_decl_const2("gm1",1,"double",&gm1  );
  op_decl_const2("cfl",1,"double",&cfl  );
  op_decl_const2("eps",1,"double",&eps  );
  op_decl_const2("mach",1,"double",&mach );
  op_decl_const2("alpha",1,"double",&alpha);
  op_decl_const2("qinf",4,"double",qinf  );

  op_diagnostic_output();

//initialising checkpointing
  bool isRestoring;
  FILE *c_fp;
  if ( (c_fp = fopen("./checkpoint.dat","r")) == NULL) {
    isRestoring = false;
    printf("//\n// Backup mode\n//\n");
  } else {
    isRestoring = true;
    printf("//\n// Restore mode\n//\n");
  }
  bool isBackingUp = !isRestoring;

  int counterRms = 60;
  double *b_rms;
  if (isBackingUp) { //create storage for variables that have to be backed up on a per-loop basis
    b_rms = (double *)malloc(counterRms*sizeof(double)); //(rms is not part of the control flow, but let's back it up anyway)
        memset(b_rms,0,counterRms*sizeof(double));
  }

  if (isRestoring) { //read in everything
    if (fscanf(c_fp,"%d \n",&counterRms) != 1) { //how many values
      printf("error reading from checkpoint file\n"); exit(-1);
    }
    b_rms = (double *)malloc(counterRms*sizeof(double)); //alloc and read in
    int b64len = 0;
    if (fscanf(c_fp,"%d \n",&b64len) != 1) { //how many values
      printf("error reading from checkpoint file\n"); exit(-1);
    }
    char *b64buffer = (char *)malloc(b64len);
    for (int i = 0; i<b64len; i++) {
      if (fscanf(c_fp,"%c",&b64buffer[i]) != 1) {
        printf("error reading from checkpoint file\n"); exit(-1);
      }
    }
    base64_decodestate decState;
    base64_init_decodestate(&decState);
    int length = base64_decode_block((const char*)b64buffer, b64len, (char*)b_rms, &decState);
    free(b64buffer);
    if (fscanf(c_fp,"\n%d \n",&b64len) != 1) { //how many values
      printf("error reading from checkpoint file\n"); exit(-1);
    }
    b64buffer = (char *)malloc(b64len);
    base64_init_decodestate(&decState);
        for (int i = 0; i<b64len; i++) { //p_q
            if (fscanf(c_fp,"%c", &b64buffer[i]) != 1) {
        printf("error reading from checkpoint file\n"); exit(-1);
      }
        }
    length = base64_decode_block((const char*)b64buffer, b64len, p_q->data, &decState);

    if (fscanf(c_fp,"\n%d \n",&b64len) != 1) { //how many values
      printf("error reading from checkpoint file\n"); exit(-1);
    }
    base64_init_decodestate(&decState);
        for (int i = 0; i<b64len; i++) { //p_qold
            if (fscanf(c_fp,"%c", &b64buffer[i]) != 1) {
        printf("error reading from checkpoint file\n"); exit(-1);
      }
        }
    length = base64_decode_block((const char*)b64buffer, b64len, p_qold->data, &decState);

    if (fscanf(c_fp,"\n%d \n",&b64len) != 1) { //how many values
      printf("error reading from checkpoint file\n"); exit(-1);
    }
    base64_init_decodestate(&decState);
        for (int i = 0; i<b64len; i++) { //p_res
            if (fscanf(c_fp,"%c", &b64buffer[i]) != 1) {
        printf("error reading from checkpoint file\n"); exit(-1);
      }
        }
    length = base64_decode_block((const char*)b64buffer, b64len, p_res->data, &decState);

    if (fscanf(c_fp,"\n%d \n",&b64len) != 1) { //how many values
      printf("error reading from checkpoint file\n"); exit(-1);
    }
    base64_init_decodestate(&decState);
        for (int i = 0; i<b64len; i++) { //p_adt
            if (fscanf(c_fp,"%c", &b64buffer[i]) != 1) {
        printf("error reading from checkpoint file\n"); exit(-1);
      }
        }
    length = base64_decode_block((const char*)b64buffer, b64len, p_adt->data, &decState);
    free(b64buffer);
    fclose(c_fp);
  }

  int save_soln_ctr = 0;
  int adt_calc_ctr = 0;
  int res_calc_ctr = 0;
  int bres_calc_ctr = 0;
  int update_ctr = 0;

// main time-marching loop

  niter = 1000;

  for(int iter=1; iter<=niter; iter++) {

//  save old flow solution
    if (isRestoring) {
    } else {
      op_par_loop_save_soln("save_soln",cells,
        op_arg_dat(p_q,-1,OP_ID,4,"double",OP_READ),
        op_arg_dat(p_qold,-1,OP_ID,4,"double",OP_WRITE));
    }
    save_soln_ctr++;
//  predictor/corrector update loop

    for(int k=0; k<2; k++) {

//    calculate area/timstep
      if (isRestoring) {
      } else {
        op_par_loop_adt_calc("adt_calc",cells,
          op_arg_dat(p_x,0,pcell,2,"double",OP_READ),
          op_arg_dat(p_x,1,pcell,2,"double",OP_READ),
          op_arg_dat(p_x,2,pcell,2,"double",OP_READ),
          op_arg_dat(p_x,3,pcell,2,"double",OP_READ),
          op_arg_dat(p_q,-1,OP_ID,4,"double",OP_READ),
          op_arg_dat(p_adt,-1,OP_ID,1,"double",OP_WRITE));
      }
      adt_calc_ctr++;
//    calculate flux residual
      if (isRestoring) {
      } else {
        op_par_loop_res_calc("res_calc",edges,
          op_arg_dat(p_x,0,pedge,2,"double",OP_READ),
          op_arg_dat(p_x,1,pedge,2,"double",OP_READ),
          op_arg_dat(p_q,0,pecell,4,"double",OP_READ),
          op_arg_dat(p_q,1,pecell,4,"double",OP_READ),
          op_arg_dat(p_adt,0,pecell,1,"double",OP_READ),
          op_arg_dat(p_adt,1,pecell,1,"double",OP_READ),
          op_arg_dat(p_res,0,pecell,4,"double",OP_INC),
          op_arg_dat(p_res,1,pecell,4,"double",OP_INC));
      }
      res_calc_ctr++;
      if (isRestoring) {
      } else {
        op_par_loop_bres_calc("bres_calc",bedges,
          op_arg_dat(p_x,0,pbedge,2,"double",OP_READ),
          op_arg_dat(p_x,1,pbedge,2,"double",OP_READ),
          op_arg_dat(p_q,0,pbecell,4,"double",OP_READ),
          op_arg_dat(p_adt,0,pbecell,1,"double",OP_READ),
          op_arg_dat(p_res,0,pbecell,4,"double",OP_INC),
          op_arg_dat(p_bound,-1,OP_ID,1,"int",OP_READ));
      }
      bres_calc_ctr++;

            //    update flow field
      rms = 0.0;
//
// backup point here
//

      if (isBackingUp && (update_ctr == counterRms)) {
                printf("Backing up...\n");
        FILE *pFile;
        pFile = fopen("./checkpoint.dat", "w");
        fprintf(pFile, "%d \n", update_ctr);
                printf("rms values\n");
        base64_encodestate encState;
        base64_init_encodestate(&encState);
        char *buffer = (char *)malloc(2*counterRms*sizeof(double));
        int length = base64_encode_block((const char*)b_rms, (counterRms)*sizeof(double), buffer, &encState);
        fprintf(pFile, "%d\n", length);
        for (int i = 0; i < length; i++) {
             fprintf(pFile, "%c", buffer[i]);
        }
        fprintf(pFile, "\n");
        free(buffer);
        printf("q\n");
        base64_init_encodestate(&encState);
        buffer = (char *)malloc(2*4*cells->size*sizeof(double));
        length = base64_encode_block((const char*)p_q->data, (cells->size*4)*sizeof(double), buffer, &encState);
        fprintf(pFile, "%d\n", length);
        for (int i = 0; i < length; i++) {
             fprintf(pFile, "%c", buffer[i]);
        }
        fprintf(pFile, "\n");

                printf("qold\n");
        base64_init_encodestate(&encState);
        length = base64_encode_block((const char*)p_qold->data, (cells->size*4)*sizeof(double), buffer, &encState);
        fprintf(pFile, "%d\n", length);
        for (int i = 0; i < length; i++) {
             fprintf(pFile, "%c", buffer[i]);
        }
        fprintf(pFile, "\n");

                printf("res\n");
                base64_init_encodestate(&encState);
        length = base64_encode_block((const char*)p_res->data, (cells->size*4)*sizeof(double), buffer, &encState);
        fprintf(pFile, "%d\n", length);
        for (int i = 0; i < length; i++) {
             fprintf(pFile, "%c", buffer[i]);
        }
        fprintf(pFile, "\n");

                printf("adt\n");
                base64_init_encodestate(&encState);
        length = base64_encode_block((const char*)p_adt->data, (cells->size)*sizeof(double), buffer, &encState);
        fprintf(pFile, "%d\n", length);
        for (int i = 0; i < length; i++) {
             fprintf(pFile, "%c", buffer[i]);
        }
        fprintf(pFile, "\n");

        fclose(pFile);
                printf("Backed up\n");
        free(buffer);

        isBackingUp = false;
      } else if (isRestoring && (update_ctr == counterRms)) {
        isRestoring = false;
        printf("Restore point reached, switching back to backup mode and doing the calculations\n");
      }

      if (isRestoring) {
        rms = b_rms[update_ctr];
      } else {
        op_par_loop_update("update",cells,
          op_arg_dat(p_qold,-1,OP_ID,4,"double",OP_READ),
          op_arg_dat(p_q,-1,OP_ID,4,"double",OP_WRITE),
          op_arg_dat(p_res,-1,OP_ID,4,"double",OP_RW),
          op_arg_dat(p_adt,-1,OP_ID,1,"double",OP_READ),
          op_arg_gbl(&rms,1,"double",OP_INC));

        if (isBackingUp) b_rms[update_ctr] = rms;
      }
      update_ctr++;
    }

//  print iteration history

    rms = sqrt(rms/(double) ncell);

    if (iter%10 == 0)
      printf(" %d  %10.5e \n",iter,rms);
  }

  op_timing_output();
  op_exit();
}

