//
// auto-generated by op2.m on 16-Oct-2012 15:15:09
//

// user function

#include "save_soln.h"

// host stub function

void op_par_loop_save_soln(op_kernel_descriptor *desc ){

  char const *name = desc->name;
  op_set set = desc->set;
  op_arg arg0 = desc->args[0];
  op_arg arg1 = desc->args[1];

  int    nargs   = 2;
  op_arg args[2];

  args[0] = arg0;
  args[1] = arg1;

  if (OP_diags>2) {
    printf(" kernel routine w/o indirection:  %s\n", name);
  }

  char  *p_a[2] = {0,0};
  
  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers_core(&cpu_t1, &wall_t1);
  
  for (int col = 0; col < desc->subset->ncolors; col++) {
    for (int n=desc->subset->color_offsets[2*col]; n<desc->subset->color_offsets[2*col+1]; n++) {
      
      
      op_arg_set(n,args[0], &p_a[0],0);
      op_arg_set(n,args[1], &p_a[1],0);
      
      // call kernel function, passing in pointers to data
      
      save_soln( (double *)p_a[0],  (double *)p_a[1]);
    }
  }
  // update timer record
  op_timers_core(&cpu_t2, &wall_t2);
  op_timing_realloc(0);
  OP_kernels[0].time     += wall_t2 - wall_t1;
}

void op_par_loop_save_soln_enqueue(char const *name, op_set set,
                                  op_arg arg0,
                                  op_arg arg1) {
  op_kernel_descriptor kern;
  kern.name = name;
  kern.set = set;
  kern.nargs = 2;
  kern.args = (op_arg *)malloc(2*sizeof(op_arg));
  kern.args[0] = arg0;
  kern.args[1] = arg1;
  kern.function = op_par_loop_save_soln;
  kernel_list.push_back(kern);
}
