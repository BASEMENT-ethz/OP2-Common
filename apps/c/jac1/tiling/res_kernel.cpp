//
// auto-generated by op2.m on 16-Oct-2012 15:15:12
//

// user function

#include "res.h"

void op_par_loop_res(op_kernel_descriptor *desc ){
  
  char const *name = desc->name;
  op_set set = desc->set;
  op_arg arg0 = desc->args[0];
  op_arg arg1 = desc->args[1];
  op_arg arg2 = desc->args[2];
  op_arg arg3 = desc->args[3];
  
  int    nargs   = 4;
  op_arg args[4];
  
  args[0] = arg0;
  args[1] = arg1;
  args[2] = arg2;
  args[3] = arg3;
  
  int    ninds   = 2;
  int    inds[4] = {-1,0,1,-1};
  
  if (OP_diags>2) {
    printf(" kernel routine with indirection: %s\n", name);
  }

//  for (int i = 0; i < set->size; i++) {
//    printf("%g ", ((double *)args[0].dat->data)[i]);
//  }
//  printf("\n");
  char  *p_a[4] = {0,0,0,0};
  
  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers_core(&cpu_t1, &wall_t1);
  
  for (int col = 0; col < desc->subset->ncolors; col++) {
    printf("Executing color %d from %d to %d\n", col, desc->subset->color_offsets[2*col], desc->subset->color_offsets[2*col+1]);
#pragma omp parallel for private(p_a)
    for (int n=desc->subset->color_offsets[2*col]; n<desc->subset->color_offsets[2*col+1]; n++) {
      op_arg_set(n,args[0], &p_a[0],0);
      op_arg_set(n,args[1], &p_a[1],0);
      op_arg_set(n,args[2], &p_a[2],0);
      op_arg_set(n,args[3], &p_a[3],0);

      // call kernel function, passing in pointers to data
      res( (double *)p_a[0],  (double *)p_a[1],  (double *)(arg2.data + arg2.size*arg2.map->map[arg2.idx+n*arg2.map->dim]),  (double *)p_a[3]);
    }
  }
  
  // update timer record
  op_timers_core(&cpu_t2, &wall_t2);
  op_timing_realloc(0);
  OP_kernels[0].time     += wall_t2 - wall_t1;
  
}


void op_par_loop_res_enqueue(char const *name, op_set set,
                                  op_arg arg0,
                                  op_arg arg1,
                                  op_arg arg2,
                                  op_arg arg3) {
  op_kernel_descriptor kern;
  kern.name = name;
  kern.set = set;
  kern.nargs = 4;
  kern.args = (op_arg *)malloc(4*sizeof(op_arg));
  kern.args[0] = arg0;
  kern.args[1] = arg1;
  kern.args[2] = arg2;
  kern.args[3] = arg3;
  kern.function = op_par_loop_res;
  kernel_list.push_back(kern);
}

