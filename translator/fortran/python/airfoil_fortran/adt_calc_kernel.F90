!
! auto-generated by op2.py on 2013-01-14 17:43
!

MODULE ADT_CALC_MODULE
USE OP2_FORTRAN_DECLARATIONS
USE OP2_FORTRAN_RT_SUPPORT
USE ISO_C_BINDING
USE OP2_CONSTANTS

#ifdef _OPENMP
  USE OMP_LIB
#endif

! variable declarations
REAL(kind=4) :: loopTimeHostadt_calc
REAL(kind=4) :: loopTimeKerneladt_calc
INTEGER(kind=4) :: numberCalledadt_calc

LOGICAL :: firstTime_adt_calc = .TRUE.
type ( c_ptr )  :: planRet_adt_calc
type ( op_plan ) , POINTER :: actualPlan_adt_calc
type ( c_ptr ) , POINTER, dimension(:) :: ind_maps_adt_calc
type ( c_ptr ) , POINTER, dimension(:) :: mappingArray_adt_calc

INTEGER(kind=4), POINTER, dimension(:) :: ind_maps1_adt_calc

INTEGER(kind=2), POINTER, dimension(:) :: mappingArray1_adt_calc
INTEGER(kind=2), POINTER, dimension(:) :: mappingArray2_adt_calc
INTEGER(kind=2), POINTER, dimension(:) :: mappingArray3_adt_calc
INTEGER(kind=2), POINTER, dimension(:) :: mappingArray4_adt_calc

INTEGER(kind=4) :: mappingArray1Size_adt_calc
INTEGER(kind=4) :: mappingArray2Size_adt_calc
INTEGER(kind=4) :: mappingArray3Size_adt_calc
INTEGER(kind=4) :: mappingArray4Size_adt_calc

INTEGER(kind=4), POINTER, dimension(:) :: blkmap_adt_calc
INTEGER(kind=4) :: blkmapSize_adt_calc
INTEGER(kind=4), POINTER, dimension(:) :: ind_offs_adt_calc
INTEGER(kind=4) :: ind_offsSize_adt_calc
INTEGER(kind=4), POINTER, dimension(:) :: ind_sizes_adt_calc
INTEGER(kind=4) :: ind_sizesSize_adt_calc
INTEGER(kind=4), POINTER, dimension(:) :: nelems_adt_calc
INTEGER(kind=4) :: nelemsSize_adt_calc
INTEGER(kind=4), POINTER, dimension(:) :: nthrcol_adt_calc
INTEGER(kind=4) :: nthrcolSize_adt_calc
INTEGER(kind=4), POINTER, dimension(:) :: offset_adt_calc
INTEGER(kind=4) :: offsetSize_adt_calc
INTEGER(kind=4), POINTER, dimension(:) :: thrcol_adt_calc
INTEGER(kind=4) :: thrcolSize_adt_calc
INTEGER(kind=4), POINTER, dimension(:) :: ncolblk_adt_calc
INTEGER(kind=4), POINTER, dimension(:) :: pnindirect_adt_calc

CONTAINS

! user function
include "adt_calc.inc"


! x86 kernel function
SUBROUTINE op_x86_adt_calc( &
  &  opDat1,   &
  &  opDat5,   &
  &  opDat6,   &
  &  ind_maps1, &
  &  mappingArray1, &
  &  mappingArray2, &
  &  mappingArray3, &
  &  mappingArray4, &
  &  ind_sizes, &
  &  ind_offs,  &
  &  blkmap,        &
  &  offset,        &
  &  nelems,        &
  &  nthrcol,       &
  &  thrcol,        &
  &  blockOffset,   &
  &  blockID )

  IMPLICIT NONE

! local variables
  REAL(kind=8), dimension(0:*) :: opDat1
  REAL(kind=8), dimension(0:*) :: opDat5
  REAL(kind=8), dimension(0:*) :: opDat6

  INTEGER(kind=4), dimension(0:), target :: ind_maps1

  INTEGER(kind=2), dimension(0:*) :: mappingArray1
  INTEGER(kind=2), dimension(0:*) :: mappingArray2
  INTEGER(kind=2), dimension(0:*) :: mappingArray3
  INTEGER(kind=2), dimension(0:*) :: mappingArray4

  INTEGER(kind=4), dimension(0:*) :: ind_sizes
  INTEGER(kind=4), dimension(0:*) :: ind_offs
  INTEGER(kind=4), dimension(0:*) :: blkmap
  INTEGER(kind=4), dimension(0:*) :: offset
  INTEGER(kind=4), dimension(0:*) :: nelems
  INTEGER(kind=4), dimension(0:*) :: nthrcol
  INTEGER(kind=4), dimension(0:*) :: thrcol
  INTEGER(kind=4) :: blockOffset
  INTEGER(kind=4) :: blockID
  INTEGER(kind=4) :: threadBlockOffset
  INTEGER(kind=4) :: threadBlockID
  INTEGER(kind=4) :: numberOfActiveThreads
  INTEGER(kind=4) :: i1
  INTEGER(kind=4) :: i2
  REAL(kind=8), dimension(0:128000 - 1), target :: sharedFloat8

  INTEGER(kind=4), POINTER, dimension(:) :: opDat1IndirectionMap
  REAL(kind=8), POINTER, dimension(:) :: opDat1SharedIndirection
  INTEGER(kind=4) :: opDat1nBytes
  INTEGER(kind=4) :: opDat1RoundUp
  INTEGER(kind=4) :: opDat1SharedIndirectionSize
  INTEGER(kind=4) :: numOfColours
  INTEGER(kind=4) :: numberOfActiveThreadsCeiling
  INTEGER(kind=4) :: colour1
  INTEGER(kind=4) :: colour2

  threadBlockID = blkmap(blockID + blockOffset)
  numberOfActiveThreads = nelems(threadBlockID)
  threadBlockOffset = offset(threadBlockID)
  numberOfActiveThreadsCeiling = numberOfActiveThreads
  numOfColours = nthrcol(threadBlockID)

  opDat1SharedIndirectionSize = ind_sizes(0 + threadBlockID * 1)
  opDat1IndirectionMap => ind_maps1(ind_offs(0 + threadBlockID * 1):)
  opDat1nBytes = 0
  opDat1SharedIndirection => sharedFloat8(opDat1nBytes:)

  DO i1 = 0, opDat1SharedIndirectionSize - 1, 1
    DO i2 = 0, 2 - 1, 1
      opDat1SharedIndirection(i2 + i1 * 2 + 1) = opDat1(i2 + opDat1IndirectionMap(i1 + 1) * 2)
    END DO
  END DO

  DO i1 = 0, numberOfActiveThreadsCeiling - 1, 1
    colour2 = -1
    IF (i1 < numberOfActiveThreads) THEN

! kernel call
      CALL adt_calc( &
      & opDat1SharedIndirection(1 + mappingArray1(i1 + threadBlockOffset) * 2:1 + mappingArray1(i1 + threadBlockOffset) * 2 + 2 - 1), &
      & opDat1SharedIndirection(1 + mappingArray2(i1 + threadBlockOffset) * 2:1 + mappingArray2(i1 + threadBlockOffset) * 2 + 2 - 1), &
      & opDat1SharedIndirection(1 + mappingArray3(i1 + threadBlockOffset) * 2:1 + mappingArray3(i1 + threadBlockOffset) * 2 + 2 - 1), &
      & opDat1SharedIndirection(1 + mappingArray4(i1 + threadBlockOffset) * 2:1 + mappingArray4(i1 + threadBlockOffset) * 2 + 2 - 1), &
      & opDat5((i1 + threadBlockOffset) * 4:(i1 + threadBlockOffset) * 4 + 4 - 1), &
      & opDat6((i1 + threadBlockOffset) * 1) &
      & )
      colour2 = thrcol(i1 + threadBlockOffset)
    END IF


    DO colour1 = 0, numOfColours - 1, 1
      IF (colour2 .EQ. colour1) THEN
      END IF
    END DO
  END DO

END SUBROUTINE

SUBROUTINE adt_calc_host( userSubroutine, set, &
  & opArg1, &
  & opArg2, &
  & opArg3, &
  & opArg4, &
  & opArg5, &
  & opArg6 )

  IMPLICIT NONE
  character(len=9), INTENT(IN) :: userSubroutine
  type ( op_set ) , INTENT(IN) :: set

  type ( op_arg ) , INTENT(IN) :: opArg1
  type ( op_arg ) , INTENT(IN) :: opArg2
  type ( op_arg ) , INTENT(IN) :: opArg3
  type ( op_arg ) , INTENT(IN) :: opArg4
  type ( op_arg ) , INTENT(IN) :: opArg5
  type ( op_arg ) , INTENT(IN) :: opArg6

  type ( op_arg ) , dimension(6) :: opArgArray
  INTEGER(kind=4) :: numberOfOpDats
  INTEGER(kind=4) :: returnMPIHaloExchange
  INTEGER(kind=4) :: returnSetKernelTiming
  type ( op_set_core ) , POINTER :: opSetCore

  type ( op_set_core ) , POINTER :: opSet1Core
  REAL(kind=8), POINTER, dimension(:) :: opDat1Local
  INTEGER(kind=4) :: opDat1Cardinality

  type ( op_set_core ) , POINTER :: opSet5Core
  REAL(kind=8), POINTER, dimension(:) :: opDat5Local
  INTEGER(kind=4) :: opDat5Cardinality

  type ( op_set_core ) , POINTER :: opSet6Core
  REAL(kind=8), POINTER, dimension(:) :: opDat6Local
  INTEGER(kind=4) :: opDat6Cardinality


  type ( op_dat_core ) , POINTER :: opDat1Core
  type ( op_dat_core ) , POINTER :: opDat2Core
  type ( op_dat_core ) , POINTER :: opDat3Core
  type ( op_dat_core ) , POINTER :: opDat4Core
  type ( op_dat_core ) , POINTER :: opDat5Core
  type ( op_dat_core ) , POINTER :: opDat6Core

  type ( op_map_core ) , POINTER :: opMap1Core
  type ( op_map_core ) , POINTER :: opMap2Core
  type ( op_map_core ) , POINTER :: opMap3Core
  type ( op_map_core ) , POINTER :: opMap4Core
  type ( op_map_core ) , POINTER :: opMap5Core
  type ( op_map_core ) , POINTER :: opMap6Core

  INTEGER(kind=4) :: threadID
  INTEGER(kind=4) :: numberOfThreads
  INTEGER(kind=4) :: partitionSize
  INTEGER(kind=4), dimension(1:6) :: opDatArray
  INTEGER(kind=4), dimension(1:6) :: mappingIndicesArray
  INTEGER(kind=4), dimension(1:6) :: mappingArray
  INTEGER(kind=4), dimension(1:6) :: accessDescriptorArray
  INTEGER(kind=4), dimension(1:6) :: indirectionDescriptorArray
  INTEGER(kind=4), dimension(1:6) :: opDatTypesArray
  INTEGER(kind=4), dimension(1:8) :: timeArrayStart
  INTEGER(kind=4), dimension(1:8) :: timeArrayEnd
  INTEGER(kind=4) :: numberOfIndirectOpDats
  INTEGER(kind=4) :: blockOffset
  INTEGER(kind=4) :: nblocks
  REAL(kind=8) :: startTimeHost
  REAL(kind=8) :: endTimeHost
  REAL(kind=8) :: startTimeKernel
  REAL(kind=8) :: endTimeKernel
  REAL(kind=8) :: accumulatorHostTime
  REAL(kind=8) :: accumulatorKernelTime
  INTEGER(kind=4) :: i1
  INTEGER(kind=4) :: i2



  IF (set%setPtr%size .EQ. 0) THEN
    RETURN
  END IF

  numberCalledadt_calc = numberCalledadt_calc+ 1

  call date_and_time(values=timeArrayStart)
  startTimeHost = 1.00000 * timeArrayStart(8) + &
  & 1000.00 * timeArrayStart(7) + &
  & 60000 * timeArrayStart(6) + &
  & 3600000 * timeArrayStart(5)
#ifdef OP_PART_SIZE_1
  partitionSize = OP_PART_SIZE_1
#else
  partitionSize = 0
#endif

#ifdef _OPENMP
  numberOfThreads = omp_get_max_threads()
#else
  numberOfThreads = 1
#endif

  numberOfOpDats = 6

  opArgArray(1) = opArg1
  opArgArray(2) = opArg2
  opArgArray(3) = opArg3
  opArgArray(4) = opArg4
  opArgArray(5) = opArg5
  opArgArray(6) = opArg6

  indirectionDescriptorArray(1) = 0
  indirectionDescriptorArray(2) = 0
  indirectionDescriptorArray(3) = 0
  indirectionDescriptorArray(4) = 0
  indirectionDescriptorArray(5) = -1
  indirectionDescriptorArray(6) = -1

  numberOfIndirectOpDats = 1

  planRet_adt_calc = FortranPlanCaller( &
  & userSubroutine, &
  & set%setCPtr, &
  & partitionSize, &
  & numberOfOpDats, &
  & opArgArray, &
  & numberOfIndirectOpDats, &
  & indirectionDescriptorArray)

  CALL c_f_pointer(planRet_adt_calc,actualPlan_adt_calc)
  CALL c_f_pointer(actualPlan_adt_calc%nindirect,pnindirect_adt_calc,(/numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_adt_calc%ind_maps,ind_maps_adt_calc,(/numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_adt_calc%maps,mappingArray_adt_calc,(/numberOfOpDats/))
  CALL c_f_pointer(actualPlan_adt_calc%ncolblk,ncolblk_adt_calc,(/set%setPtr%size/))
  CALL c_f_pointer(actualPlan_adt_calc%ind_sizes,ind_sizes_adt_calc,(/actualPlan_adt_calc%nblocks * numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_adt_calc%ind_offs,ind_offs_adt_calc,(/actualPlan_adt_calc%nblocks * numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_adt_calc%blkmap,blkmap_adt_calc,(/actualPlan_adt_calc%nblocks/))
  CALL c_f_pointer(actualPlan_adt_calc%offset,offset_adt_calc,(/actualPlan_adt_calc%nblocks/))
  CALL c_f_pointer(actualPlan_adt_calc%nelems,nelems_adt_calc,(/actualPlan_adt_calc%nblocks/))
  CALL c_f_pointer(actualPlan_adt_calc%nthrcol,nthrcol_adt_calc,(/actualPlan_adt_calc%nblocks/))
  CALL c_f_pointer(actualPlan_adt_calc%thrcol,thrcol_adt_calc,(/set%setPtr%size/))

  CALL c_f_pointer(ind_maps_adt_calc(1),ind_maps1_adt_calc,(/pnindirect_adt_calc(1)/))

  IF (indirectionDescriptorArray(1) >= 0) THEN
    CALL c_f_pointer(mappingArray_adt_calc(1),mappingArray1_adt_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(2) >= 0) THEN
    CALL c_f_pointer(mappingArray_adt_calc(2),mappingArray2_adt_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(3) >= 0) THEN
    CALL c_f_pointer(mappingArray_adt_calc(3),mappingArray3_adt_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(4) >= 0) THEN
    CALL c_f_pointer(mappingArray_adt_calc(4),mappingArray4_adt_calc,(/set%setPtr%size/))
  END IF

  opSetCore => set%setPtr

  opDat1Cardinality = opArg1%dim * getSetSizeFromOpArg(opArg1)
  opDat1Cardinality = opArg5%dim * getSetSizeFromOpArg(opArg5)
  opDat1Cardinality = opArg6%dim * getSetSizeFromOpArg(opArg6)

  CALL c_f_pointer(opArg1%data,opDat1Local,(/opDat1Cardinality/))
  CALL c_f_pointer(opArg5%data,opDat5Local,(/opDat5Cardinality/))
  CALL c_f_pointer(opArg6%data,opDat6Local,(/opDat6Cardinality/))


  call date_and_time(values=timeArrayEnd)
  endTimeHost = 1.00000 * timeArrayEnd(8) + &
  & 1000 * timeArrayEnd(7)  + &
  & 60000 * timeArrayEnd(6) + &
  & 3600000 * timeArrayEnd(5)

  accumulatorHostTime = endTimeHost - startTimeHost
  loopTimeHostadt_calc = loopTimeHostadt_calc + accumulatorHostTime

  call date_and_time(values=timeArrayStart)
  startTimeKernel = 1.00000 * timeArrayStart(8) + &
  & 1000 * timeArrayStart(7) + &
  & 60000 * timeArrayStart(6) + &
  & 3600000 * timeArrayStart(5)

  blockOffset = 0

  DO i1 = 0, actualPlan_adt_calc%ncolors - 1, 1
    nblocks = ncolblk_adt_calc(i1 + 1)
    !$OMP PARALLEL DO private (threadID)
    DO i2 = 0, nblocks - 1, 1
      threadID = omp_get_thread_num()
      CALL op_x86_adt_calc( &
      & opDat1Local, &
      & opDat5Local, &
      & opDat6Local, &
      & ind_maps1_adt_calc, &
      & mappingArray1_adt_calc, &
      & mappingArray2_adt_calc, &
      & mappingArray3_adt_calc, &
      & mappingArray4_adt_calc, &
      & ind_sizes_adt_calc, &
      & ind_offs_adt_calc, &
      & blkmap_adt_calc, &
      & offset_adt_calc, &
      & nelems_adt_calc, &
      & nthrcol_adt_calc, &
      & thrcol_adt_calc, &
      & blockOffset,i2)
    END DO
    !$OMP END PARALLEL DO
    blockOffset = blockOffset + nblocks
  END DO


  call date_and_time(values=timeArrayEnd)
  endTimeKernel = 1.00000 * timeArrayEnd(8) + &
  & 1000 * timeArrayEnd(7) + &
  & 60000 * timeArrayEnd(6) + &
  & 3600000 * timeArrayEnd(5)

  accumulatorKernelTime = endTimeKernel - startTimeKernel
  loopTimeKerneladt_calc = loopTimeKerneladt_calc + accumulatorKernelTime

  call date_and_time(values=timeArrayStart)
  startTimeHost = 1.00000 * timeArrayStart(8) + &
  & 1000.00 * timeArrayStart(7) + &
  & 60000 * timeArrayStart(6) + &
  & 3600000 * timeArrayStart(5)

  call date_and_time(values=timeArrayEnd)
  endTimeHost = 1.00000 * timeArrayEnd(8) + &
  1000 * timeArrayEnd(7) + &
  60000 * timeArrayEnd(6) + &
  3600000 * timeArrayEnd(5)

  accumulatorHostTime = endTimeHost - startTimeHost
  loopTimeHostadt_calc = loopTimeHostadt_calc + accumulatorHostTime

  returnSetKernelTiming = setKernelTime(1 , userSubroutine, &
  & accumulatorKernelTime / 1000.00,actualPlan_adt_calc%transfer,actualPlan_adt_calc%transfer2)

END SUBROUTINE
END MODULE ADT_CALC_MODULE
