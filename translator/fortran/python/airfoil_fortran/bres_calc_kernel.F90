!
! auto-generated by op2.py on 2013-01-14 17:43
!

MODULE BRES_CALC_MODULE
USE OP2_FORTRAN_DECLARATIONS
USE OP2_FORTRAN_RT_SUPPORT
USE ISO_C_BINDING
USE OP2_CONSTANTS

#ifdef _OPENMP
  USE OMP_LIB
#endif

! variable declarations
REAL(kind=4) :: loopTimeHostbres_calc
REAL(kind=4) :: loopTimeKernelbres_calc
INTEGER(kind=4) :: numberCalledbres_calc

LOGICAL :: firstTime_bres_calc = .TRUE.
type ( c_ptr )  :: planRet_bres_calc
type ( op_plan ) , POINTER :: actualPlan_bres_calc
type ( c_ptr ) , POINTER, dimension(:) :: ind_maps_bres_calc
type ( c_ptr ) , POINTER, dimension(:) :: mappingArray_bres_calc

INTEGER(kind=4), POINTER, dimension(:) :: ind_maps1_bres_calc
INTEGER(kind=4), POINTER, dimension(:) :: ind_maps3_bres_calc
INTEGER(kind=4), POINTER, dimension(:) :: ind_maps4_bres_calc
INTEGER(kind=4), POINTER, dimension(:) :: ind_maps5_bres_calc

INTEGER(kind=2), POINTER, dimension(:) :: mappingArray1_bres_calc
INTEGER(kind=2), POINTER, dimension(:) :: mappingArray2_bres_calc
INTEGER(kind=2), POINTER, dimension(:) :: mappingArray3_bres_calc
INTEGER(kind=2), POINTER, dimension(:) :: mappingArray4_bres_calc
INTEGER(kind=2), POINTER, dimension(:) :: mappingArray5_bres_calc

INTEGER(kind=4) :: mappingArray1Size_bres_calc
INTEGER(kind=4) :: mappingArray2Size_bres_calc
INTEGER(kind=4) :: mappingArray3Size_bres_calc
INTEGER(kind=4) :: mappingArray4Size_bres_calc
INTEGER(kind=4) :: mappingArray5Size_bres_calc

INTEGER(kind=4), POINTER, dimension(:) :: blkmap_bres_calc
INTEGER(kind=4) :: blkmapSize_bres_calc
INTEGER(kind=4), POINTER, dimension(:) :: ind_offs_bres_calc
INTEGER(kind=4) :: ind_offsSize_bres_calc
INTEGER(kind=4), POINTER, dimension(:) :: ind_sizes_bres_calc
INTEGER(kind=4) :: ind_sizesSize_bres_calc
INTEGER(kind=4), POINTER, dimension(:) :: nelems_bres_calc
INTEGER(kind=4) :: nelemsSize_bres_calc
INTEGER(kind=4), POINTER, dimension(:) :: nthrcol_bres_calc
INTEGER(kind=4) :: nthrcolSize_bres_calc
INTEGER(kind=4), POINTER, dimension(:) :: offset_bres_calc
INTEGER(kind=4) :: offsetSize_bres_calc
INTEGER(kind=4), POINTER, dimension(:) :: thrcol_bres_calc
INTEGER(kind=4) :: thrcolSize_bres_calc
INTEGER(kind=4), POINTER, dimension(:) :: ncolblk_bres_calc
INTEGER(kind=4), POINTER, dimension(:) :: pnindirect_bres_calc

CONTAINS

! user function
include "bres_calc.inc"


! x86 kernel function
SUBROUTINE op_x86_bres_calc( &
  &  opDat1,   &
  &  opDat3,   &
  &  opDat4,   &
  &  opDat5,   &
  &  opDat6,   &
  &  ind_maps1, &
  &  ind_maps3, &
  &  ind_maps4, &
  &  ind_maps5, &
  &  mappingArray1, &
  &  mappingArray2, &
  &  mappingArray3, &
  &  mappingArray4, &
  &  mappingArray5, &
  &  ind_sizes, &
  &  ind_offs,  &
  &  blkmap,        &
  &  offset,        &
  &  nelems,        &
  &  nthrcol,       &
  &  thrcol,        &
  &  blockOffset,   &
  &  blockID )

  IMPLICIT NONE

! local variables
  REAL(kind=8), dimension(0:*) :: opDat1
  REAL(kind=8), dimension(0:*) :: opDat3
  REAL(kind=8), dimension(0:*) :: opDat4
  REAL(kind=8), dimension(0:*) :: opDat5
  INTEGER(kind=4), dimension(0:*) :: opDat6

  INTEGER(kind=4), dimension(0:), target :: ind_maps1
  INTEGER(kind=4), dimension(0:), target :: ind_maps3
  INTEGER(kind=4), dimension(0:), target :: ind_maps4
  INTEGER(kind=4), dimension(0:), target :: ind_maps5

  INTEGER(kind=2), dimension(0:*) :: mappingArray1
  INTEGER(kind=2), dimension(0:*) :: mappingArray2
  INTEGER(kind=2), dimension(0:*) :: mappingArray3
  INTEGER(kind=2), dimension(0:*) :: mappingArray4
  INTEGER(kind=2), dimension(0:*) :: mappingArray5

  INTEGER(kind=4), dimension(0:*) :: ind_sizes
  INTEGER(kind=4), dimension(0:*) :: ind_offs
  INTEGER(kind=4), dimension(0:*) :: blkmap
  INTEGER(kind=4), dimension(0:*) :: offset
  INTEGER(kind=4), dimension(0:*) :: nelems
  INTEGER(kind=4), dimension(0:*) :: nthrcol
  INTEGER(kind=4), dimension(0:*) :: thrcol
  INTEGER(kind=4) :: blockOffset
  INTEGER(kind=4) :: blockID
  INTEGER(kind=4) :: threadBlockOffset
  INTEGER(kind=4) :: threadBlockID
  INTEGER(kind=4) :: numberOfActiveThreads
  INTEGER(kind=4) :: i1
  INTEGER(kind=4) :: i2
  REAL(kind=8), dimension(0:128000 - 1), target :: sharedFloat8

  INTEGER(kind=4), POINTER, dimension(:) :: opDat1IndirectionMap
  REAL(kind=8), POINTER, dimension(:) :: opDat1SharedIndirection
  INTEGER(kind=4), POINTER, dimension(:) :: opDat3IndirectionMap
  REAL(kind=8), POINTER, dimension(:) :: opDat3SharedIndirection
  INTEGER(kind=4), POINTER, dimension(:) :: opDat4IndirectionMap
  REAL(kind=8), POINTER, dimension(:) :: opDat4SharedIndirection
  INTEGER(kind=4), POINTER, dimension(:) :: opDat5IndirectionMap
  REAL(kind=8), POINTER, dimension(:) :: opDat5SharedIndirection
  INTEGER(kind=4) :: opDat1nBytes
  INTEGER(kind=4) :: opDat3nBytes
  INTEGER(kind=4) :: opDat4nBytes
  INTEGER(kind=4) :: opDat5nBytes
  INTEGER(kind=4) :: opDat1RoundUp
  INTEGER(kind=4) :: opDat3RoundUp
  INTEGER(kind=4) :: opDat4RoundUp
  INTEGER(kind=4) :: opDat5RoundUp
  INTEGER(kind=4) :: opDat1SharedIndirectionSize
  INTEGER(kind=4) :: opDat3SharedIndirectionSize
  INTEGER(kind=4) :: opDat4SharedIndirectionSize
  INTEGER(kind=4) :: opDat5SharedIndirectionSize
  REAL(kind=8), dimension(0:3) :: opDat5Local
  INTEGER(kind=4) :: opDat5Map
  INTEGER(kind=4) :: numOfColours
  INTEGER(kind=4) :: numberOfActiveThreadsCeiling
  INTEGER(kind=4) :: colour1
  INTEGER(kind=4) :: colour2

  threadBlockID = blkmap(blockID + blockOffset)
  numberOfActiveThreads = nelems(threadBlockID)
  threadBlockOffset = offset(threadBlockID)
  numberOfActiveThreadsCeiling = numberOfActiveThreads
  numOfColours = nthrcol(threadBlockID)

  opDat1SharedIndirectionSize = ind_sizes(0 + threadBlockID * 4)
  opDat3SharedIndirectionSize = ind_sizes(1 + threadBlockID * 4)
  opDat4SharedIndirectionSize = ind_sizes(2 + threadBlockID * 4)
  opDat5SharedIndirectionSize = ind_sizes(3 + threadBlockID * 4)
  opDat1IndirectionMap => ind_maps1(ind_offs(0 + threadBlockID * 4):)
  opDat3IndirectionMap => ind_maps3(ind_offs(1 + threadBlockID * 4):)
  opDat4IndirectionMap => ind_maps4(ind_offs(2 + threadBlockID * 4):)
  opDat5IndirectionMap => ind_maps5(ind_offs(3 + threadBlockID * 4):)
  opDat3RoundUp = opDat1SharedIndirectionSize * 2
  opDat4RoundUp = opDat3SharedIndirectionSize * 4
  opDat5RoundUp = opDat4SharedIndirectionSize * 1
  opDat1nBytes = 0
  opDat3nBytes = opDat1nBytes + opDat3RoundUp
  opDat4nBytes = opDat3nBytes + opDat4RoundUp
  opDat5nBytes = opDat4nBytes + opDat5RoundUp
  opDat1SharedIndirection => sharedFloat8(opDat1nBytes:)
  opDat3SharedIndirection => sharedFloat8(opDat3nBytes:)
  opDat4SharedIndirection => sharedFloat8(opDat4nBytes:)
  opDat5SharedIndirection => sharedFloat8(opDat5nBytes:)

  DO i1 = 0, opDat1SharedIndirectionSize - 1, 1
    DO i2 = 0, 2 - 1, 1
      opDat1SharedIndirection(i2 + i1 * 2 + 1) = opDat1(i2 + opDat1IndirectionMap(i1 + 1) * 2)
    END DO
  END DO

  DO i1 = 0, opDat3SharedIndirectionSize - 1, 1
    DO i2 = 0, 4 - 1, 1
      opDat3SharedIndirection(i2 + i1 * 4 + 1) = opDat3(i2 + opDat3IndirectionMap(i1 + 1) * 4)
    END DO
  END DO

  DO i1 = 0, opDat4SharedIndirectionSize - 1, 1
    DO i2 = 0, 1 - 1, 1
      opDat4SharedIndirection(i2 + i1 * 1 + 1) = opDat4(i2 + opDat4IndirectionMap(i1 + 1) * 1)
    END DO
  END DO

  DO i1 = 0, opDat5SharedIndirectionSize - 1, 1
    DO i2 = 0, 4 - 1, 1
      opDat5SharedIndirection(i2 + i1 * 4 + 1) = 0
    END DO
  END DO

  DO i1 = 0, numberOfActiveThreadsCeiling - 1, 1
    colour2 = -1
    IF (i1 < numberOfActiveThreads) THEN
      DO i2 = 0, 4 - 1, 1
        opDat5Local(i2) = 0
      END DO

! kernel call
      CALL bres_calc( &
      & opDat1SharedIndirection(1 + mappingArray1(i1 + threadBlockOffset) * 2:1 + mappingArray1(i1 + threadBlockOffset) * 2 + 2 - 1), &
      & opDat1SharedIndirection(1 + mappingArray2(i1 + threadBlockOffset) * 2:1 + mappingArray2(i1 + threadBlockOffset) * 2 + 2 - 1), &
      & opDat3SharedIndirection(1 + mappingArray3(i1 + threadBlockOffset) * 4:1 + mappingArray3(i1 + threadBlockOffset) * 4 + 4 - 1), &
      & opDat4SharedIndirection(1 + mappingArray4(i1 + threadBlockOffset) * 1), &
      & opDat5Local, &
      & opDat6((i1 + threadBlockOffset) * 1) &
      & )
      colour2 = thrcol(i1 + threadBlockOffset)
    END IF

    opDat5Map = mappingArray5(i1 + threadBlockOffset)

    DO colour1 = 0, numOfColours - 1, 1
      IF (colour2 .EQ. colour1) THEN
        DO i2 = 0, 4 - 1, 1
          opDat5SharedIndirection(1 + (i2 + opDat5Map * 4)) = opDat5SharedIndirection(1 + (i2 + opDat5Map * 1)) + opDat5Local(i2)
        END DO

      END IF
    END DO
  END DO

  DO i1 = 0, opDat5SharedIndirectionSize - 1, 1
    DO i2 = 0, 4 - 1, 1
      opDat5(i2 + opDat5IndirectionMap(i1 + 1) * 4) = opDat5(i2 + opDat5IndirectionMap(i1 + 1) * 4) + opDat5SharedIndirection(1 + (i2 + i1 * 4))
    END DO
  END DO
END SUBROUTINE

SUBROUTINE bres_calc_host( userSubroutine, set, &
  & opArg1, &
  & opArg2, &
  & opArg3, &
  & opArg4, &
  & opArg5, &
  & opArg6 )

  IMPLICIT NONE
  character(len=10), INTENT(IN) :: userSubroutine
  type ( op_set ) , INTENT(IN) :: set

  type ( op_arg ) , INTENT(IN) :: opArg1
  type ( op_arg ) , INTENT(IN) :: opArg2
  type ( op_arg ) , INTENT(IN) :: opArg3
  type ( op_arg ) , INTENT(IN) :: opArg4
  type ( op_arg ) , INTENT(IN) :: opArg5
  type ( op_arg ) , INTENT(IN) :: opArg6

  type ( op_arg ) , dimension(6) :: opArgArray
  INTEGER(kind=4) :: numberOfOpDats
  INTEGER(kind=4) :: returnMPIHaloExchange
  INTEGER(kind=4) :: returnSetKernelTiming
  type ( op_set_core ) , POINTER :: opSetCore

  type ( op_set_core ) , POINTER :: opSet1Core
  REAL(kind=8), POINTER, dimension(:) :: opDat1Local
  INTEGER(kind=4) :: opDat1Cardinality

  type ( op_set_core ) , POINTER :: opSet3Core
  REAL(kind=8), POINTER, dimension(:) :: opDat3Local
  INTEGER(kind=4) :: opDat3Cardinality

  type ( op_set_core ) , POINTER :: opSet4Core
  REAL(kind=8), POINTER, dimension(:) :: opDat4Local
  INTEGER(kind=4) :: opDat4Cardinality

  type ( op_set_core ) , POINTER :: opSet5Core
  REAL(kind=8), POINTER, dimension(:) :: opDat5Local
  INTEGER(kind=4) :: opDat5Cardinality

  type ( op_set_core ) , POINTER :: opSet6Core
  INTEGER(kind=4), POINTER, dimension(:) :: opDat6Local
  INTEGER(kind=4) :: opDat6Cardinality


  type ( op_dat_core ) , POINTER :: opDat1Core
  type ( op_dat_core ) , POINTER :: opDat2Core
  type ( op_dat_core ) , POINTER :: opDat3Core
  type ( op_dat_core ) , POINTER :: opDat4Core
  type ( op_dat_core ) , POINTER :: opDat5Core
  type ( op_dat_core ) , POINTER :: opDat6Core

  type ( op_map_core ) , POINTER :: opMap1Core
  type ( op_map_core ) , POINTER :: opMap2Core
  type ( op_map_core ) , POINTER :: opMap3Core
  type ( op_map_core ) , POINTER :: opMap4Core
  type ( op_map_core ) , POINTER :: opMap5Core
  type ( op_map_core ) , POINTER :: opMap6Core

  INTEGER(kind=4) :: threadID
  INTEGER(kind=4) :: numberOfThreads
  INTEGER(kind=4) :: partitionSize
  INTEGER(kind=4), dimension(1:6) :: opDatArray
  INTEGER(kind=4), dimension(1:6) :: mappingIndicesArray
  INTEGER(kind=4), dimension(1:6) :: mappingArray
  INTEGER(kind=4), dimension(1:6) :: accessDescriptorArray
  INTEGER(kind=4), dimension(1:6) :: indirectionDescriptorArray
  INTEGER(kind=4), dimension(1:6) :: opDatTypesArray
  INTEGER(kind=4), dimension(1:8) :: timeArrayStart
  INTEGER(kind=4), dimension(1:8) :: timeArrayEnd
  INTEGER(kind=4) :: numberOfIndirectOpDats
  INTEGER(kind=4) :: blockOffset
  INTEGER(kind=4) :: nblocks
  REAL(kind=8) :: startTimeHost
  REAL(kind=8) :: endTimeHost
  REAL(kind=8) :: startTimeKernel
  REAL(kind=8) :: endTimeKernel
  REAL(kind=8) :: accumulatorHostTime
  REAL(kind=8) :: accumulatorKernelTime
  INTEGER(kind=4) :: i1
  INTEGER(kind=4) :: i2



  IF (set%setPtr%size .EQ. 0) THEN
    RETURN
  END IF

  numberCalledbres_calc = numberCalledbres_calc+ 1

  call date_and_time(values=timeArrayStart)
  startTimeHost = 1.00000 * timeArrayStart(8) + &
  & 1000.00 * timeArrayStart(7) + &
  & 60000 * timeArrayStart(6) + &
  & 3600000 * timeArrayStart(5)
#ifdef OP_PART_SIZE_1
  partitionSize = OP_PART_SIZE_1
#else
  partitionSize = 0
#endif

#ifdef _OPENMP
  numberOfThreads = omp_get_max_threads()
#else
  numberOfThreads = 1
#endif

  numberOfOpDats = 6

  opArgArray(1) = opArg1
  opArgArray(2) = opArg2
  opArgArray(3) = opArg3
  opArgArray(4) = opArg4
  opArgArray(5) = opArg5
  opArgArray(6) = opArg6

  indirectionDescriptorArray(1) = 0
  indirectionDescriptorArray(2) = 0
  indirectionDescriptorArray(3) = 1
  indirectionDescriptorArray(4) = 2
  indirectionDescriptorArray(5) = 3
  indirectionDescriptorArray(6) = -1

  numberOfIndirectOpDats = 4

  planRet_bres_calc = FortranPlanCaller( &
  & userSubroutine, &
  & set%setCPtr, &
  & partitionSize, &
  & numberOfOpDats, &
  & opArgArray, &
  & numberOfIndirectOpDats, &
  & indirectionDescriptorArray)

  CALL c_f_pointer(planRet_bres_calc,actualPlan_bres_calc)
  CALL c_f_pointer(actualPlan_bres_calc%nindirect,pnindirect_bres_calc,(/numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_bres_calc%ind_maps,ind_maps_bres_calc,(/numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_bres_calc%maps,mappingArray_bres_calc,(/numberOfOpDats/))
  CALL c_f_pointer(actualPlan_bres_calc%ncolblk,ncolblk_bres_calc,(/set%setPtr%size/))
  CALL c_f_pointer(actualPlan_bres_calc%ind_sizes,ind_sizes_bres_calc,(/actualPlan_bres_calc%nblocks * numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_bres_calc%ind_offs,ind_offs_bres_calc,(/actualPlan_bres_calc%nblocks * numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_bres_calc%blkmap,blkmap_bres_calc,(/actualPlan_bres_calc%nblocks/))
  CALL c_f_pointer(actualPlan_bres_calc%offset,offset_bres_calc,(/actualPlan_bres_calc%nblocks/))
  CALL c_f_pointer(actualPlan_bres_calc%nelems,nelems_bres_calc,(/actualPlan_bres_calc%nblocks/))
  CALL c_f_pointer(actualPlan_bres_calc%nthrcol,nthrcol_bres_calc,(/actualPlan_bres_calc%nblocks/))
  CALL c_f_pointer(actualPlan_bres_calc%thrcol,thrcol_bres_calc,(/set%setPtr%size/))

  CALL c_f_pointer(ind_maps_bres_calc(1),ind_maps1_bres_calc,(/pnindirect_bres_calc(1)/))
  CALL c_f_pointer(ind_maps_bres_calc(2),ind_maps3_bres_calc,(/pnindirect_bres_calc(2)/))
  CALL c_f_pointer(ind_maps_bres_calc(3),ind_maps4_bres_calc,(/pnindirect_bres_calc(3)/))
  CALL c_f_pointer(ind_maps_bres_calc(4),ind_maps5_bres_calc,(/pnindirect_bres_calc(4)/))

  IF (indirectionDescriptorArray(1) >= 0) THEN
    CALL c_f_pointer(mappingArray_bres_calc(1),mappingArray1_bres_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(2) >= 0) THEN
    CALL c_f_pointer(mappingArray_bres_calc(2),mappingArray2_bres_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(3) >= 0) THEN
    CALL c_f_pointer(mappingArray_bres_calc(3),mappingArray3_bres_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(4) >= 0) THEN
    CALL c_f_pointer(mappingArray_bres_calc(4),mappingArray4_bres_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(5) >= 0) THEN
    CALL c_f_pointer(mappingArray_bres_calc(5),mappingArray5_bres_calc,(/set%setPtr%size/))
  END IF


  opSetCore => set%setPtr

  opDat1Cardinality = opArg1%dim * getSetSizeFromOpArg(opArg1)
  opDat3Cardinality = opArg3%dim * getSetSizeFromOpArg(opArg3)
  opDat4Cardinality = opArg4%dim * getSetSizeFromOpArg(opArg4)
  opDat5Cardinality = opArg5%dim * getSetSizeFromOpArg(opArg5)
  opDat1Cardinality = opArg6%dim * getSetSizeFromOpArg(opArg6)

  CALL c_f_pointer(opArg1%data,opDat1Local,(/opDat1Cardinality/))
  CALL c_f_pointer(opArg3%data,opDat3Local,(/opDat3Cardinality/))
  CALL c_f_pointer(opArg4%data,opDat4Local,(/opDat4Cardinality/))
  CALL c_f_pointer(opArg5%data,opDat5Local,(/opDat5Cardinality/))
  CALL c_f_pointer(opArg6%data,opDat6Local,(/opDat6Cardinality/))


  call date_and_time(values=timeArrayEnd)
  endTimeHost = 1.00000 * timeArrayEnd(8) + &
  & 1000 * timeArrayEnd(7)  + &
  & 60000 * timeArrayEnd(6) + &
  & 3600000 * timeArrayEnd(5)

  accumulatorHostTime = endTimeHost - startTimeHost
  loopTimeHostbres_calc = loopTimeHostbres_calc + accumulatorHostTime

  call date_and_time(values=timeArrayStart)
  startTimeKernel = 1.00000 * timeArrayStart(8) + &
  & 1000 * timeArrayStart(7) + &
  & 60000 * timeArrayStart(6) + &
  & 3600000 * timeArrayStart(5)

  blockOffset = 0

  DO i1 = 0, actualPlan_bres_calc%ncolors - 1, 1
    nblocks = ncolblk_bres_calc(i1 + 1)
    !$OMP PARALLEL DO private (threadID)
    DO i2 = 0, nblocks - 1, 1
      threadID = omp_get_thread_num()
      CALL op_x86_bres_calc( &
      & opDat1Local, &
      & opDat3Local, &
      & opDat4Local, &
      & opDat5Local, &
      & opDat6Local, &
      & ind_maps1_bres_calc, &
      & ind_maps3_bres_calc, &
      & ind_maps4_bres_calc, &
      & ind_maps5_bres_calc, &
      & mappingArray1_bres_calc, &
      & mappingArray2_bres_calc, &
      & mappingArray3_bres_calc, &
      & mappingArray4_bres_calc, &
      & mappingArray5_bres_calc, &
      & ind_sizes_bres_calc, &
      & ind_offs_bres_calc, &
      & blkmap_bres_calc, &
      & offset_bres_calc, &
      & nelems_bres_calc, &
      & nthrcol_bres_calc, &
      & thrcol_bres_calc, &
      & blockOffset,i2)
    END DO
    !$OMP END PARALLEL DO
    blockOffset = blockOffset + nblocks
  END DO


  call date_and_time(values=timeArrayEnd)
  endTimeKernel = 1.00000 * timeArrayEnd(8) + &
  & 1000 * timeArrayEnd(7) + &
  & 60000 * timeArrayEnd(6) + &
  & 3600000 * timeArrayEnd(5)

  accumulatorKernelTime = endTimeKernel - startTimeKernel
  loopTimeKernelbres_calc = loopTimeKernelbres_calc + accumulatorKernelTime

  call date_and_time(values=timeArrayStart)
  startTimeHost = 1.00000 * timeArrayStart(8) + &
  & 1000.00 * timeArrayStart(7) + &
  & 60000 * timeArrayStart(6) + &
  & 3600000 * timeArrayStart(5)

  call date_and_time(values=timeArrayEnd)
  endTimeHost = 1.00000 * timeArrayEnd(8) + &
  1000 * timeArrayEnd(7) + &
  60000 * timeArrayEnd(6) + &
  3600000 * timeArrayEnd(5)

  accumulatorHostTime = endTimeHost - startTimeHost
  loopTimeHostbres_calc = loopTimeHostbres_calc + accumulatorHostTime

  returnSetKernelTiming = setKernelTime(3 , userSubroutine, &
  & accumulatorKernelTime / 1000.00,actualPlan_bres_calc%transfer,actualPlan_bres_calc%transfer2)

END SUBROUTINE
END MODULE BRES_CALC_MODULE
