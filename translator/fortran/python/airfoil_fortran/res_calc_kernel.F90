!
! auto-generated by op2.py on 2013-01-23 12:10
!

MODULE RES_CALC_MODULE
USE OP2_FORTRAN_DECLARATIONS
USE OP2_FORTRAN_RT_SUPPORT
USE ISO_C_BINDING
USE OP2_CONSTANTS

#ifdef _OPENMP
  USE OMP_LIB
#endif

! variable declarations
REAL(kind=4) :: loopTimeHostres_calc
REAL(kind=4) :: loopTimeKernelres_calc
INTEGER(kind=4) :: numberCalledres_calc

LOGICAL :: firstTime_res_calc = .TRUE.
type ( c_ptr )  :: planRet_res_calc
type ( op_plan ) , POINTER :: actualPlan_res_calc
type ( c_ptr ) , POINTER, DIMENSION(:) :: ind_maps_res_calc
type ( c_ptr ) , POINTER, DIMENSION(:) :: mappingArray_res_calc

INTEGER(kind=4), POINTER, DIMENSION(:) :: ind_maps1_res_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: ind_maps3_res_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: ind_maps5_res_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: ind_maps7_res_calc

INTEGER(kind=2), POINTER, DIMENSION(:) :: mappingArray1_res_calc
INTEGER(kind=2), POINTER, DIMENSION(:) :: mappingArray2_res_calc
INTEGER(kind=2), POINTER, DIMENSION(:) :: mappingArray3_res_calc
INTEGER(kind=2), POINTER, DIMENSION(:) :: mappingArray4_res_calc
INTEGER(kind=2), POINTER, DIMENSION(:) :: mappingArray5_res_calc
INTEGER(kind=2), POINTER, DIMENSION(:) :: mappingArray6_res_calc
INTEGER(kind=2), POINTER, DIMENSION(:) :: mappingArray7_res_calc
INTEGER(kind=2), POINTER, DIMENSION(:) :: mappingArray8_res_calc

INTEGER(kind=4) :: mappingArray1Size_res_calc
INTEGER(kind=4) :: mappingArray2Size_res_calc
INTEGER(kind=4) :: mappingArray3Size_res_calc
INTEGER(kind=4) :: mappingArray4Size_res_calc
INTEGER(kind=4) :: mappingArray5Size_res_calc
INTEGER(kind=4) :: mappingArray6Size_res_calc
INTEGER(kind=4) :: mappingArray7Size_res_calc
INTEGER(kind=4) :: mappingArray8Size_res_calc

INTEGER(kind=4), POINTER, DIMENSION(:) :: blkmap_res_calc
INTEGER(kind=4) :: blkmapSize_res_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: ind_offs_res_calc
INTEGER(kind=4) :: ind_offsSize_res_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: ind_sizes_res_calc
INTEGER(kind=4) :: ind_sizesSize_res_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: nelems_res_calc
INTEGER(kind=4) :: nelemsSize_res_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: nthrcol_res_calc
INTEGER(kind=4) :: nthrcolSize_res_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: offset_res_calc
INTEGER(kind=4) :: offsetSize_res_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: thrcol_res_calc
INTEGER(kind=4) :: thrcolSize_res_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: ncolblk_res_calc
INTEGER(kind=4), POINTER, DIMENSION(:) :: pnindirect_res_calc

CONTAINS

! user function
include "res_calc.inc"


! x86 kernel function
SUBROUTINE op_x86_res_calc( &
  &  opDat1,   &
  &  opDat3,   &
  &  opDat5,   &
  &  opDat7,   &
  &  ind_maps1, &
  &  ind_maps3, &
  &  ind_maps5, &
  &  ind_maps7, &
  &  mappingArray1, &
  &  mappingArray2, &
  &  mappingArray3, &
  &  mappingArray4, &
  &  mappingArray5, &
  &  mappingArray6, &
  &  mappingArray7, &
  &  mappingArray8, &
  &  ind_sizes, &
  &  ind_offs,  &
  &  blkmap,        &
  &  offset,        &
  &  nelems,        &
  &  nthrcol,       &
  &  thrcol,        &
  &  blockOffset,   &
  &  blockID )

  IMPLICIT NONE

! local variables
  real(8), DIMENSION(0:*) :: opDat1
  real(8), DIMENSION(0:*) :: opDat3
  real(8), DIMENSION(0:*) :: opDat5
  real(8), DIMENSION(0:*) :: opDat7

  INTEGER(kind=4), DIMENSION(0:), target :: ind_maps1
  INTEGER(kind=4), DIMENSION(0:), target :: ind_maps3
  INTEGER(kind=4), DIMENSION(0:), target :: ind_maps5
  INTEGER(kind=4), DIMENSION(0:), target :: ind_maps7

  INTEGER(kind=2), DIMENSION(0:*) :: mappingArray1
  INTEGER(kind=2), DIMENSION(0:*) :: mappingArray2
  INTEGER(kind=2), DIMENSION(0:*) :: mappingArray3
  INTEGER(kind=2), DIMENSION(0:*) :: mappingArray4
  INTEGER(kind=2), DIMENSION(0:*) :: mappingArray5
  INTEGER(kind=2), DIMENSION(0:*) :: mappingArray6
  INTEGER(kind=2), DIMENSION(0:*) :: mappingArray7
  INTEGER(kind=2), DIMENSION(0:*) :: mappingArray8

  INTEGER(kind=4), DIMENSION(0:*) :: ind_sizes
  INTEGER(kind=4), DIMENSION(0:*) :: ind_offs
  INTEGER(kind=4), DIMENSION(0:*) :: blkmap
  INTEGER(kind=4), DIMENSION(0:*) :: offset
  INTEGER(kind=4), DIMENSION(0:*) :: nelems
  INTEGER(kind=4), DIMENSION(0:*) :: nthrcol
  INTEGER(kind=4), DIMENSION(0:*) :: thrcol
  INTEGER(kind=4) :: blockOffset
  INTEGER(kind=4) :: blockID
  INTEGER(kind=4) :: threadBlockOffset
  INTEGER(kind=4) :: threadBlockID
  INTEGER(kind=4) :: numberOfActiveThreads
  INTEGER(kind=4) :: i1
  INTEGER(kind=4) :: i2
  REAL(kind=8), DIMENSION(0:128000 - 1), target :: sharedFloat8

  INTEGER(kind=4), POINTER, DIMENSION(:) :: opDat1IndirectionMap
  real(8), POINTER, DIMENSION(:) :: opDat1SharedIndirection
  INTEGER(kind=4), POINTER, DIMENSION(:) :: opDat3IndirectionMap
  real(8), POINTER, DIMENSION(:) :: opDat3SharedIndirection
  INTEGER(kind=4), POINTER, DIMENSION(:) :: opDat5IndirectionMap
  real(8), POINTER, DIMENSION(:) :: opDat5SharedIndirection
  INTEGER(kind=4), POINTER, DIMENSION(:) :: opDat7IndirectionMap
  real(8), POINTER, DIMENSION(:) :: opDat7SharedIndirection
  INTEGER(kind=4) :: opDat1nBytes
  INTEGER(kind=4) :: opDat3nBytes
  INTEGER(kind=4) :: opDat5nBytes
  INTEGER(kind=4) :: opDat7nBytes
  INTEGER(kind=4) :: opDat1RoundUp
  INTEGER(kind=4) :: opDat3RoundUp
  INTEGER(kind=4) :: opDat5RoundUp
  INTEGER(kind=4) :: opDat7RoundUp
  INTEGER(kind=4) :: opDat1SharedIndirectionSize
  INTEGER(kind=4) :: opDat3SharedIndirectionSize
  INTEGER(kind=4) :: opDat5SharedIndirectionSize
  INTEGER(kind=4) :: opDat7SharedIndirectionSize
  REAL(kind=8), DIMENSION(0:3) :: opDat7Local
  INTEGER(kind=4) :: opDat7Map
  REAL(kind=8), DIMENSION(0:3) :: opDat8Local
  INTEGER(kind=4) :: opDat8Map
  INTEGER(kind=4) :: numOfColours
  INTEGER(kind=4) :: numberOfActiveThreadsCeiling
  INTEGER(kind=4) :: colour1
  INTEGER(kind=4) :: colour2

  threadBlockID = blkmap(blockID + blockOffset)
  numberOfActiveThreads = nelems(threadBlockID)
  threadBlockOffset = offset(threadBlockID)
  numberOfActiveThreadsCeiling = numberOfActiveThreads
  numOfColours = nthrcol(threadBlockID)

  opDat1SharedIndirectionSize = ind_sizes(0 + threadBlockID * 4)
  opDat3SharedIndirectionSize = ind_sizes(1 + threadBlockID * 4)
  opDat5SharedIndirectionSize = ind_sizes(2 + threadBlockID * 4)
  opDat7SharedIndirectionSize = ind_sizes(3 + threadBlockID * 4)
  opDat1IndirectionMap => ind_maps1(ind_offs(0 + threadBlockID * 4):)
  opDat3IndirectionMap => ind_maps3(ind_offs(1 + threadBlockID * 4):)
  opDat5IndirectionMap => ind_maps5(ind_offs(2 + threadBlockID * 4):)
  opDat7IndirectionMap => ind_maps7(ind_offs(3 + threadBlockID * 4):)
  opDat3RoundUp = opDat1SharedIndirectionSize * 2
  opDat5RoundUp = opDat3SharedIndirectionSize * 4
  opDat7RoundUp = opDat5SharedIndirectionSize * 1
  opDat1nBytes = 0
  opDat3nBytes = opDat1nBytes + opDat3RoundUp
  opDat5nBytes = opDat3nBytes + opDat5RoundUp
  opDat7nBytes = opDat5nBytes + opDat7RoundUp
  opDat1SharedIndirection => sharedFloat8(opDat1nBytes:)
  opDat3SharedIndirection => sharedFloat8(opDat3nBytes:)
  opDat5SharedIndirection => sharedFloat8(opDat5nBytes:)
  opDat7SharedIndirection => sharedFloat8(opDat7nBytes:)

  DO i1 = 0, opDat1SharedIndirectionSize-1, 1
    DO i2 = 0, 2-1, 1
      opDat1SharedIndirection(i2 + i1 * 2 + 1) = opDat1(i2 + opDat1IndirectionMap(i1 + 1) * 2)
    END DO
  END DO

  DO i1 = 0, opDat3SharedIndirectionSize-1, 1
    DO i2 = 0, 4-1, 1
      opDat3SharedIndirection(i2 + i1 * 4 + 1) = opDat3(i2 + opDat3IndirectionMap(i1 + 1) * 4)
    END DO
  END DO

  DO i1 = 0, opDat5SharedIndirectionSize-1, 1
    DO i2 = 0, 1-1, 1
      opDat5SharedIndirection(i2 + i1 * 1 + 1) = opDat5(i2 + opDat5IndirectionMap(i1 + 1) * 1)
    END DO
  END DO

  DO i1 = 0, opDat7SharedIndirectionSize-1, 1
    DO i2 = 0, 4-1, 1
      opDat7SharedIndirection(i2 + i1 * 4 + 1) = 0
    END DO
  END DO

  DO i1 = 0, numberOfActiveThreadsCeiling-1, 1
      colour2 = -1
    IF (i1 < numberOfActiveThreads) THEN
      DO i2 = 0, 4-1, 1
        opDat7Local(i2) = 0
      END DO
      DO i2 = 0, 4-1, 1
        opDat8Local(i2) = 0
      END DO

! kernel call
    CALL res_calc( &
      & opDat1SharedIndirection(1 + mappingArray1(i1 + threadBlockOffset) * 2:1 + mappingArray1(i1 + threadBlockOffset) * 2 + 2 - 1), &
      & opDat1SharedIndirection(1 + mappingArray2(i1 + threadBlockOffset) * 2:1 + mappingArray2(i1 + threadBlockOffset) * 2 + 2 - 1), &
      & opDat3SharedIndirection(1 + mappingArray3(i1 + threadBlockOffset) * 4:1 + mappingArray3(i1 + threadBlockOffset) * 4 + 4 - 1), &
      & opDat3SharedIndirection(1 + mappingArray4(i1 + threadBlockOffset) * 4:1 + mappingArray4(i1 + threadBlockOffset) * 4 + 4 - 1), &
      & opDat5SharedIndirection(1 + mappingArray5(i1 + threadBlockOffset) * 1), &
      & opDat5SharedIndirection(1 + mappingArray6(i1 + threadBlockOffset) * 1), &
      & opDat7Local, &
      & opDat8Local &
      & )
      colour2 = thrcol(i1 + threadBlockOffset)
    END IF

    opDat7Map = mappingArray7(i1 + threadBlockOffset)
    opDat8Map = mappingArray8(i1 + threadBlockOffset)

    DO colour1 = 0, numOfColours-1, 1
      IF (colour2 .EQ. colour1) THEN
        DO i2 = 0, 4-1, 1
          opDat7SharedIndirection(1 + (i2 + opDat7Map * 4)) = opDat7SharedIndirection(1 + (i2 + opDat7Map * 4)) + opDat7Local(i2)
        END DO

        DO i2 = 0, 4-1, 1
          opDat7SharedIndirection(1 + (i2 + opDat8Map * 4)) = opDat7SharedIndirection(1 + (i2 + opDat8Map * 4)) + opDat8Local(i2)
        END DO

      END IF
    END DO
  END DO

  DO i1 = 0, opDat7SharedIndirectionSize-1, 1
    DO i2 = 0, 4-1, 1
      opDat7(i2 + opDat7IndirectionMap(i1 + 1) * 4) = opDat7(i2 + opDat7IndirectionMap(i1 + 1) * 4) + opDat7SharedIndirection(1 + (i2 + i1 * 4))
    END DO
  END DO
END SUBROUTINE

SUBROUTINE res_calc_host( userSubroutine, set, &
  & opArg1, &
  & opArg2, &
  & opArg3, &
  & opArg4, &
  & opArg5, &
  & opArg6, &
  & opArg7, &
  & opArg8 )

  IMPLICIT NONE
  character(len=9), INTENT(IN) :: userSubroutine
  type ( op_set ) , INTENT(IN) :: set

  type ( op_arg ) , INTENT(IN) :: opArg1
  type ( op_arg ) , INTENT(IN) :: opArg2
  type ( op_arg ) , INTENT(IN) :: opArg3
  type ( op_arg ) , INTENT(IN) :: opArg4
  type ( op_arg ) , INTENT(IN) :: opArg5
  type ( op_arg ) , INTENT(IN) :: opArg6
  type ( op_arg ) , INTENT(IN) :: opArg7
  type ( op_arg ) , INTENT(IN) :: opArg8

  type ( op_arg ) , DIMENSION(8) :: opArgArray
  INTEGER(kind=4) :: numberOfOpDats
  INTEGER(kind=4) :: returnMPIHaloExchange
  INTEGER(kind=4) :: returnSetKernelTiming
  type ( op_set_core ) , POINTER :: opSetCore

  type ( op_set_core ) , POINTER :: opSet1Core
  real(8), POINTER, DIMENSION(:) :: opDat1Local
  INTEGER(kind=4) :: opDat1Cardinality

  type ( op_set_core ) , POINTER :: opSet3Core
  real(8), POINTER, DIMENSION(:) :: opDat3Local
  INTEGER(kind=4) :: opDat3Cardinality

  type ( op_set_core ) , POINTER :: opSet5Core
  real(8), POINTER, DIMENSION(:) :: opDat5Local
  INTEGER(kind=4) :: opDat5Cardinality

  type ( op_set_core ) , POINTER :: opSet7Core
  real(8), POINTER, DIMENSION(:) :: opDat7Local
  INTEGER(kind=4) :: opDat7Cardinality


  type ( op_dat_core ) , POINTER :: opDat1Core
  type ( op_dat_core ) , POINTER :: opDat2Core
  type ( op_dat_core ) , POINTER :: opDat3Core
  type ( op_dat_core ) , POINTER :: opDat4Core
  type ( op_dat_core ) , POINTER :: opDat5Core
  type ( op_dat_core ) , POINTER :: opDat6Core
  type ( op_dat_core ) , POINTER :: opDat7Core
  type ( op_dat_core ) , POINTER :: opDat8Core

  type ( op_map_core ) , POINTER :: opMap1Core
  type ( op_map_core ) , POINTER :: opMap2Core
  type ( op_map_core ) , POINTER :: opMap3Core
  type ( op_map_core ) , POINTER :: opMap4Core
  type ( op_map_core ) , POINTER :: opMap5Core
  type ( op_map_core ) , POINTER :: opMap6Core
  type ( op_map_core ) , POINTER :: opMap7Core
  type ( op_map_core ) , POINTER :: opMap8Core

  INTEGER(kind=4) :: threadID
  INTEGER(kind=4) :: numberOfThreads
  INTEGER(kind=4) :: partitionSize
  INTEGER(kind=4), DIMENSION(1:8) :: opDatArray
  INTEGER(kind=4), DIMENSION(1:8) :: mappingIndicesArray
  INTEGER(kind=4), DIMENSION(1:8) :: mappingArray
  INTEGER(kind=4), DIMENSION(1:8) :: accessDescriptorArray
  INTEGER(kind=4), DIMENSION(1:8) :: indirectionDescriptorArray
  INTEGER(kind=4), DIMENSION(1:8) :: opDatTypesArray
  INTEGER(kind=4), DIMENSION(1:8) :: timeArrayStart
  INTEGER(kind=4), DIMENSION(1:8) :: timeArrayEnd
  INTEGER(kind=4) :: numberOfIndirectOpDats
  INTEGER(kind=4) :: blockOffset
  INTEGER(kind=4) :: nblocks
  REAL(kind=8) :: startTimeHost
  REAL(kind=8) :: endTimeHost
  REAL(kind=8) :: startTimeKernel
  REAL(kind=8) :: endTimeKernel
  REAL(kind=8) :: accumulatorHostTime
  REAL(kind=8) :: accumulatorKernelTime
  INTEGER(kind=4) :: i1
  INTEGER(kind=4) :: i2


  IF (set%setPtr%size .EQ. 0) THEN
    RETURN
  END IF

  numberCalledres_calc = numberCalledres_calc+ 1

  call date_and_time(values=timeArrayStart)
  startTimeHost = 1.00000 * timeArrayStart(8) + &
  & 1000.00 * timeArrayStart(7) + &
  & 60000 * timeArrayStart(6) + &
  & 3600000 * timeArrayStart(5)

#ifdef OP_PART_SIZE_1
  partitionSize = OP_PART_SIZE_1
#else
  partitionSize = 0
#endif

#ifdef _OPENMP
  numberOfThreads = omp_get_max_threads()
#else
  numberOfThreads = 1
#endif

  numberOfOpDats = 8

  opArgArray(1) = opArg1
  opArgArray(2) = opArg2
  opArgArray(3) = opArg3
  opArgArray(4) = opArg4
  opArgArray(5) = opArg5
  opArgArray(6) = opArg6
  opArgArray(7) = opArg7
  opArgArray(8) = opArg8

  indirectionDescriptorArray(1) = 0
  indirectionDescriptorArray(2) = 0
  indirectionDescriptorArray(3) = 1
  indirectionDescriptorArray(4) = 1
  indirectionDescriptorArray(5) = 2
  indirectionDescriptorArray(6) = 2
  indirectionDescriptorArray(7) = 3
  indirectionDescriptorArray(8) = 3

  numberOfIndirectOpDats = 4

  planRet_res_calc = FortranPlanCaller( &
  & userSubroutine, &
  & set%setCPtr, &
  & partitionSize, &
  & numberOfOpDats, &
  & opArgArray, &
  & numberOfIndirectOpDats, &
  & indirectionDescriptorArray)

  CALL c_f_pointer(planRet_res_calc,actualPlan_res_calc)
  CALL c_f_pointer(actualPlan_res_calc%nindirect,pnindirect_res_calc,(/numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_res_calc%ind_maps,ind_maps_res_calc,(/numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_res_calc%maps,mappingArray_res_calc,(/numberOfOpDats/))
  CALL c_f_pointer(actualPlan_res_calc%ncolblk,ncolblk_res_calc,(/set%setPtr%size/))
  CALL c_f_pointer(actualPlan_res_calc%ind_sizes,ind_sizes_res_calc,(/actualPlan_res_calc%nblocks * numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_res_calc%ind_offs,ind_offs_res_calc,(/actualPlan_res_calc%nblocks * numberOfIndirectOpDats/))
  CALL c_f_pointer(actualPlan_res_calc%blkmap,blkmap_res_calc,(/actualPlan_res_calc%nblocks/))
  CALL c_f_pointer(actualPlan_res_calc%offset,offset_res_calc,(/actualPlan_res_calc%nblocks/))
  CALL c_f_pointer(actualPlan_res_calc%nelems,nelems_res_calc,(/actualPlan_res_calc%nblocks/))
  CALL c_f_pointer(actualPlan_res_calc%nthrcol,nthrcol_res_calc,(/actualPlan_res_calc%nblocks/))
  CALL c_f_pointer(actualPlan_res_calc%thrcol,thrcol_res_calc,(/set%setPtr%size/))

  CALL c_f_pointer(ind_maps_res_calc(1),ind_maps1_res_calc,(/pnindirect_res_calc(1)/))
  CALL c_f_pointer(ind_maps_res_calc(2),ind_maps3_res_calc,(/pnindirect_res_calc(2)/))
  CALL c_f_pointer(ind_maps_res_calc(3),ind_maps5_res_calc,(/pnindirect_res_calc(3)/))
  CALL c_f_pointer(ind_maps_res_calc(4),ind_maps7_res_calc,(/pnindirect_res_calc(4)/))

  IF (indirectionDescriptorArray(1) >= 0) THEN
    CALL c_f_pointer(mappingArray_res_calc(1),mappingArray1_res_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(2) >= 0) THEN
    CALL c_f_pointer(mappingArray_res_calc(2),mappingArray2_res_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(3) >= 0) THEN
    CALL c_f_pointer(mappingArray_res_calc(3),mappingArray3_res_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(4) >= 0) THEN
    CALL c_f_pointer(mappingArray_res_calc(4),mappingArray4_res_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(5) >= 0) THEN
    CALL c_f_pointer(mappingArray_res_calc(5),mappingArray5_res_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(6) >= 0) THEN
    CALL c_f_pointer(mappingArray_res_calc(6),mappingArray6_res_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(7) >= 0) THEN
    CALL c_f_pointer(mappingArray_res_calc(7),mappingArray7_res_calc,(/set%setPtr%size/))
  END IF

  IF (indirectionDescriptorArray(8) >= 0) THEN
    CALL c_f_pointer(mappingArray_res_calc(8),mappingArray8_res_calc,(/set%setPtr%size/))
  END IF


  opSetCore => set%setPtr

  opDat1Cardinality = opArg1%dim * getSetSizeFromOpArg(opArg1)
  opDat3Cardinality = opArg3%dim * getSetSizeFromOpArg(opArg3)
  opDat5Cardinality = opArg5%dim * getSetSizeFromOpArg(opArg5)
  opDat7Cardinality = opArg7%dim * getSetSizeFromOpArg(opArg7)

  CALL c_f_pointer(opArg1%data,opDat1Local,(/opDat1Cardinality/))
  CALL c_f_pointer(opArg3%data,opDat3Local,(/opDat3Cardinality/))
  CALL c_f_pointer(opArg5%data,opDat5Local,(/opDat5Cardinality/))
  CALL c_f_pointer(opArg7%data,opDat7Local,(/opDat7Cardinality/))


  call date_and_time(values=timeArrayEnd)
  endTimeHost = 1.00000 * timeArrayEnd(8) + &
  & 1000 * timeArrayEnd(7)  + &
  & 60000 * timeArrayEnd(6) + &
  & 3600000 * timeArrayEnd(5)

  accumulatorHostTime = endTimeHost - startTimeHost
  loopTimeHostres_calc = loopTimeHostres_calc + accumulatorHostTime

  call date_and_time(values=timeArrayStart)
  startTimeKernel = 1.00000 * timeArrayStart(8) + &
  & 1000 * timeArrayStart(7) + &
  & 60000 * timeArrayStart(6) + &
  & 3600000 * timeArrayStart(5)

  blockOffset = 0

  DO i1 = 0, actualPlan_res_calc%ncolors-1, 1
    nblocks = ncolblk_res_calc(i1 + 1)
    !$OMP PARALLEL DO private (threadID)
    DO i2 = 0, nblocks-1, 1
      threadID = omp_get_thread_num()
      CALL op_x86_res_calc( &
      & opDat1Local, &
      & opDat3Local, &
      & opDat5Local, &
      & opDat7Local, &
      & ind_maps1_res_calc, &
      & ind_maps3_res_calc, &
      & ind_maps5_res_calc, &
      & ind_maps7_res_calc, &
      & mappingArray1_res_calc, &
      & mappingArray2_res_calc, &
      & mappingArray3_res_calc, &
      & mappingArray4_res_calc, &
      & mappingArray5_res_calc, &
      & mappingArray6_res_calc, &
      & mappingArray7_res_calc, &
      & mappingArray8_res_calc, &
      & ind_sizes_res_calc, &
      & ind_offs_res_calc, &
      & blkmap_res_calc, &
      & offset_res_calc, &
      & nelems_res_calc, &
      & nthrcol_res_calc, &
      & thrcol_res_calc, &
      & blockOffset,i2)
    END DO
    !$OMP END PARALLEL DO
    blockOffset = blockOffset + nblocks
  END DO


  call date_and_time(values=timeArrayEnd)
  endTimeKernel = 1.00000 * timeArrayEnd(8) + &
  & 1000 * timeArrayEnd(7) + &
  & 60000 * timeArrayEnd(6) + &
  & 3600000 * timeArrayEnd(5)

  accumulatorKernelTime = endTimeKernel - startTimeKernel
  loopTimeKernelres_calc = loopTimeKernelres_calc + accumulatorKernelTime

  call date_and_time(values=timeArrayStart)
  startTimeHost = 1.00000 * timeArrayStart(8) + &
  & 1000.00 * timeArrayStart(7) + &
  & 60000 * timeArrayStart(6) + &
  & 3600000 * timeArrayStart(5)

  call date_and_time(values=timeArrayEnd)
  endTimeHost = 1.00000 * timeArrayEnd(8) + &
  1000 * timeArrayEnd(7) + &
  60000 * timeArrayEnd(6) + &
  3600000 * timeArrayEnd(5)

  accumulatorHostTime = endTimeHost - startTimeHost
  loopTimeHostres_calc = loopTimeHostres_calc + accumulatorHostTime

  returnSetKernelTiming = setKernelTime(2 , userSubroutine, &
  & accumulatorKernelTime / 1000.00,actualPlan_res_calc%transfer,actualPlan_res_calc%transfer2)
END SUBROUTINE
END MODULE RES_CALC_MODULE
