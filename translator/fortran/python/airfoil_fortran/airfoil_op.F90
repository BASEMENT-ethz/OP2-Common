!
! auto-generated by op2.py on 2013-01-14 17:43
!

program AIRFOIL
  use SAVE_SOLN_MODULE
  use ADT_CALC_MODULE
  use BRES_CALC_MODULE
  use RES_CALC_MODULE
  use UPDATE_MODULE
  use OP2_FORTRAN_DECLARATIONS
  use OP2_CONSTANTS
  use input
  use, intrinsic :: ISO_C_BINDING

  implicit none

  intrinsic :: sqrt, real

  integer(4) :: iter, k, i

  integer(4), parameter :: maxnode = 9900
  integer(4), parameter :: maxcell = (9702+1)
  integer(4), parameter :: maxedge = 19502

  integer(4), parameter :: iterationNumber = 1000

  integer(4) :: nnode, ncell, nbedge, nedge, niter, qdim
  real(8) :: ncellr

  ! integer references (valid inside the OP2 library) for op_set
  type(op_set) :: nodes, edges, bedges, cells

  ! integer references (valid inside the OP2 library) for pointers between data sets
  type(op_map) :: pedge, pecell, pcell, pbedge, pbecell

  ! integer reference (valid inside the OP2 library) for op_data
  type(op_dat) :: p_bound, p_x, p_q, p_qold, p_adt, p_res

  ! arrays used in data
  integer(4), dimension(:), allocatable, target :: ecell, bound, edge, bedge, becell, cell
  real(8), dimension(:), allocatable, target :: x, q, qold, adt, res
  real(8) :: rms

  character(kind=c_char,len=10) :: savesolnName = 'save_soln'//C_NULL_CHAR
  character(kind=c_char, len=9) :: adtcalcName  = 'adt_calc' // C_NULL_CHAR
  character(kind=c_char, len=9) :: rescalcName  = 'res_calc' // C_NULL_CHAR
  character(kind=c_char,len=10) :: brescalcName = 'bres_calc' // C_NULL_CHAR
  character(kind=c_char, len=7) :: updateName   = 'update' // C_NULL_CHAR

  character(kind=c_char,len=6) :: nodesName  = 'nodes'//C_NULL_CHAR
  character(kind=c_char,len=6) :: edgesName  = 'edges'//C_NULL_CHAR
  character(kind=c_char,len=7) :: bedgesName = 'bedges'//C_NULL_CHAR
  character(kind=c_char,len=6) :: cellsName  = 'cells'//C_NULL_CHAR

  character(kind=c_char,len=6) :: pedgeName   = 'pedge'//C_NULL_CHAR
  character(kind=c_char,len=7) :: pecellName  = 'pecell'//C_NULL_CHAR
  character(kind=c_char,len=6) :: pcellName   = 'pcell'//C_NULL_CHAR
  character(kind=c_char,len=7) :: pbedgeName  = 'pbedge'//C_NULL_CHAR
  character(kind=c_char,len=8) :: pbecellName = 'pbecell'//C_NULL_CHAR

  character(kind=c_char,len=6) :: boundName = 'bound'//C_NULL_CHAR
  character(kind=c_char,len=2) :: xName     = 'x'//C_NULL_CHAR
  character(kind=c_char,len=2) :: qName     = 'q'//C_NULL_CHAR
  character(kind=c_char,len=5) :: qoldName  = 'qold'//C_NULL_CHAR
  character(kind=c_char,len=4) :: adtName   = 'adt'//C_NULL_CHAR
  character(kind=c_char,len=4) :: resName   = 'res'//C_NULL_CHAR

  character(kind=c_char,len=4) :: gamName   = 'gam'//C_NULL_CHAR
  character(kind=c_char,len=4) :: gm1Name   = 'gm1'//C_NULL_CHAR
  character(kind=c_char,len=4) :: cflName   = 'cfl'//C_NULL_CHAR
  character(kind=c_char,len=4) :: epsName   = 'eps'//C_NULL_CHAR
  character(kind=c_char,len=5) :: machName   = 'mach'//C_NULL_CHAR
  character(kind=c_char,len=6) :: alphaName   = 'alpha'//C_NULL_CHAR
  character(kind=c_char,len=5) :: qinfName   = 'qinf'//C_NULL_CHAR

  integer(4) :: debugiter, retDebug
  real(8) :: datad

  ! read set sizes from input file (input is subdivided in two routines as we cannot allocate arrays in subroutines in
  ! fortran 90)
  print *, "Getting set sizes"
  call getSetSizes ( nnode, ncell, nedge, nbedge )

  print *, ncell
  ! allocate sets (cannot allocate in subroutine in F90)
  allocate ( cell ( 4 * ncell ) )
  allocate ( edge ( 2 * nedge ) )
  allocate ( ecell ( 2 * nedge ) )
  allocate ( bedge ( 2 * nbedge ) )
  allocate ( becell ( nbedge ) )
  allocate ( bound ( nbedge ) )

  allocate ( x ( 2 * nnode ) )
  allocate ( q ( 4 * ncell ) )
  allocate ( qold ( 4 * ncell ) )
  allocate ( res ( 4 * ncell ) )
  allocate ( adt ( ncell ) )

  print *, "Getting data"
  call getSetInfo ( nnode, ncell, nedge, nbedge, cell, edge, ecell, bedge, becell, bound, x, q, qold, res, adt )

  print *, "Initialising constants"
  call initialise_flow_field ( ncell, q, res )

  do iter = 1, 4*ncell
    res(iter) = 0.0
  end do

  ! OP initialisation
  print *, "Initialising OP2"
  call op_init (0)

  ! declare sets, pointers, datasets and global constants (for now, no new partition info)
  print *, "Declaring OP2 sets"
  call op_decl_set ( nnode, nodes, nodesName )
  call op_decl_set ( nedge, edges, edgesName )
  call op_decl_set ( nbedge, bedges, bedgesName )
  call op_decl_set ( ncell, cells, cellsName )

  print *, "Declaring OP2 maps"
  call op_decl_map ( edges, nodes, 2, edge, pedge, pedgeName )
  call op_decl_map ( edges, cells, 2, ecell, pecell, pecellName )
  call op_decl_map ( bedges, nodes, 2, bedge, pbedge, pbedgeName )
  call op_decl_map ( bedges, cells, 1, becell, pbecell, pecellName )
  call op_decl_map ( cells, nodes, 4, cell, pcell, pcellName )

  print *, "Declaring OP2 data"
  call op_decl_dat ( bedges, 1, bound, p_bound, boundName )
  call op_decl_dat ( nodes, 2, x, p_x, xName )
  call op_decl_dat ( cells, 4, q, p_q, qName )
  call op_decl_dat ( cells, 4, qold, p_qold, qoldName )
  call op_decl_dat ( cells, 1, adt, p_adt, adtName )
  call op_decl_dat ( cells, 4, res, p_res, resName )

  print *, "Declaring OP2 constants"
  call op_decl_const (gam, 1, gamName)
  call op_decl_const (gm1, 1, gm1Name)
  call op_decl_const (cfl, 1, cflName)
  call op_decl_const (eps, 1, epsName)
  call op_decl_const (mach, 1, machName)
  call op_decl_const (alpha, 1, alphaName)
  call op_decl_const (qinf, 4, qinfName)

  qdim = 4


    ! main time-marching loop

  do niter = 1, iterationNumber

     call save_soln_host("save_soln" // CHAR(0), cells, &
                      & op_arg_gbl(qdim,OP_READ), &
                      & op_arg_dat(p_q,-1,OP_ID,OP_READ), &
                      & op_arg_dat(p_qold,-1,OP_ID,OP_WRITE))

    ! predictor/corrector update loop

    do k = 1, 2

      ! calculate area/timstep
      call adt_calc_host("adt_calc" // CHAR(0), cells, &
                       & op_arg_dat(p_x,1,pcell,OP_READ), &
                       & op_arg_dat(p_x,2,pcell,OP_READ), &
                       & op_arg_dat(p_x,3,pcell,OP_READ), &
                       & op_arg_dat(p_x,4,pcell,OP_READ), &
                       & op_arg_dat(p_q,-1,OP_ID,OP_READ), &
                       & op_arg_dat(p_adt,-1,OP_ID,OP_WRITE))

      ! calculate flux residual
      call res_calc_host("res_calc" // CHAR(0), edges, &
                       & op_arg_dat(p_x,1,pedge,OP_READ), &
                       & op_arg_dat(p_x,2,pedge,OP_READ), &
                       & op_arg_dat(p_q,1,pecell,OP_READ), &
                       & op_arg_dat(p_q,2,pecell,OP_READ), &
                       & op_arg_dat(p_adt,1,pecell,OP_READ), &
                       & op_arg_dat(p_adt,2,pecell,OP_READ), &
                       & op_arg_dat(p_res,1,pecell,OP_INC), &
                       & op_arg_dat(p_res,2,pecell,OP_INC))

      call bres_calc_host("bres_calc" // CHAR(0), bedges, &
                       & op_arg_dat(p_x,1,pbedge,OP_READ), &
                       & op_arg_dat(p_x,2,pbedge,OP_READ), &
                       & op_arg_dat(p_q,1,pbecell,OP_READ), &
                       & op_arg_dat(p_adt,1,pbecell,OP_READ), &
                       & op_arg_dat(p_res,1,pbecell,OP_INC), &
                       & op_arg_dat(p_bound,-1,OP_ID,OP_READ))

      ! update flow field

      rms = 0.0

      call update_host("update"// CHAR(0), cells, &
                       & op_arg_dat(p_qold,-1,OP_ID,OP_READ), &
                       & op_arg_dat(p_q,-1,OP_ID,OP_WRITE), &
                       & op_arg_dat(p_res,-1,OP_ID,OP_RW), &
                       & op_arg_dat(p_adt,-1,OP_ID,OP_READ), &
                       & op_arg_gbl(rms,OP_INC))


    end do ! internal loop

    ncellr = real ( ncell )
    rms = sqrt ( rms / ncellr )

    if (mod(niter,100) .eq. 0) print *, "=====> Iteration result ", rms

  end do ! external loop

end program AIRFOIL
